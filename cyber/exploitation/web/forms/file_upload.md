# File upload

[![uploadvulns](../../../_badges/thmp/uploadvulns.svg)](https://tryhackme.com/room/uploadvulns)

<div class="row row-cols-md-2"><div>

It's common for websites to allow users to upload files such as an avatar. In some cases unfortunately, a hacker can upload malicious files such as a script leading to **Remote Code Execution** (RCE); which also mean Remote Command Execution.

Usually, most website have filters, but they are often logic flaws in the filtering, leading to malicious files passing them.
</div><div>

**Impact ðŸ’¥**: the hacker can upload a webshell or a reverse shell, and may take full control of the machine using privilege escalation.

**Vectors**: Forms.
</div></div>

<hr class="sep-both">

## Process

<div class="row row-cols-md-2"><div>

**Identify the filters, the upload folder...**

* âœ… Upload a valid file
* ðŸ” Look for the folder where the file was uploaded
* â›” Try to upload a file that may be rejected
* ðŸ”“ If it was rejected, try a lot of payloads to see what the filter is using to assess that a file can/can't be accepted. See the filter evasion section below. Try testing your valid file with
  * the extension of the one that was rejected
  * the MIME type of the one that was rejected
  * the magic number of the one that was rejected
  * ...
* Try testing different file size to find the maximum upload size

> There may be JavaScript filters, and to be more efficient while making requests, I would advise using [Burp Suite](/cyber/exploitation/web/burpsuite/index.md#repeater-tab) Repeater.

You can also do the request manually:

```bash
# submit a file with name=file, path=path/to/file
$ curl -X POST -F "submit:value" -F "file:@path/to/file" URL
```
</div><div>

**Remediation** ðŸ§¯

* Do not use a well-known name for your uploads (`uploads`, `images`...)

* Disable indexing

* Add a limit to the size of uploaded file (ex: in a `.htaccess`)

* Do not expose uploaded files if there is no reason for them to be available to the user. You could also restrict access with a `.htaccess` only allowing the local website to access them.

* Use multiple filters/ways to assess that a file is what you expect.

* Do not rely on HTML/JS filtering, as they can be bypassed
</div></div>

<hr class="sep-both">

## Filter evasion

*PHP functions that may be involved: `pathinfo`...*

<div class="row row-cols-md-2 mt-4"><div>

* bypass check of the extension being in the filename

```
malicious.png.php
```

* bypass blacklists/deny list

```
malicious.png.PHP // may not work
malicious.png.pHp // may not work
malicious.png.php5
malicious.png.php7
malicious.png.phtml
malicious.png.phps
malicious.png.pht
malicious.png.phar
```
</div><div>

* Manually edit the [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types) which is stored inside the `Content-Type` header of your request.

```
Content-Type: application/php -> image/png
```

* Try spoofing the file magic number. Using command such as `file xxx`, you can see the type of your file. This is done by checking the first bytes of the file for a value called [magic number](https://en.wikipedia.org/wiki/List_of_file_signatures).

```bash
# Ex for a GIFT (6 bytes)
$ cat script.png
# add 6 dummy character at the start
xxxxxx[...]
$ hexeditor script.png
# replace the first 6 bytes with GIFs magic number
# 47 49 46 38 37 61
```

* Try the null byte <small>(PHP < 5.3.4)</small>

```
malicious.php%00.png -> malicious.php
```
</div></div>

<hr class="sep-both">

### Random

<div class="row row-cols-md-2"><div>

...
</div><div>

...
</div></div>