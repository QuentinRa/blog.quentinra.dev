# Bruteforce forms, and other vulnerabilities

<div class="row row-cols-md-2"><div>

There are two kinds of forms: **GET forms**, in which the parameters of the form are stored within the URL, and anyone opening the URL, will see the form filled with the same input. For instance, a search engine such as Google has a parameter `q` (short for query) for which the value is the search I made (`hello world`) was stored in.

```
https://www.google.com/search?q=hello+world
https://www.google.com/search?q=hello%20world
```

Parameters are URL-encoded as a URL is a long suite of characters with no spaces, so the space was replaced with `%20`, while `+` also works.
</div><div>

Then, we have **POST forms**. They are mostly used for logins/... Once the user submit data, then its encoded, and sent to the server. Even if we have the same URL, the page will be empty for us.

```
https://example.com/login.php
```

The common point between the two are that the data transferred is looking like this: `username=toto&password=toto`, and in both, it's URL-encoded.
</div></div>

> **Note**: BurpSuite can be used to brute force forms too with the [Intruder tab](/cyber/exploitation/web/burpsuite/index.md).<br>

<hr class="sep-both">

## Logic Flaw

[![authenticationbypass](../../../_badges/thmp/authenticationbypass.svg)](https://tryhackme.com/room/authenticationbypass)

<div class="row row-cols-md-2"><div>

In PHP, there is a variable `$_POST` to fetch the input fields send to the server using POST, and `$_GET` for input fields send using GET. There is another prefilled variable: `$_REQUEST` which contains both values in `$_GET`, and values in `$_POST`. 

If a value is both in `$_POST`, AND `$_GET`, then ONLY the value in `$_POST` will be kept. This is worth mentioning, because

* a developer might use `$_REQUEST` for a GET form, instead of `$_GET`. In such case, we may be able to inject data using POST, so that even if the data send using GET is filtered, we may bypass these filters.

```bash
$ curl 'URL?param=value' -d 'param=not_filtered'
# the dev filter $_GET: filterXXX($_GET)
# but in $_REQUEST['param'], there will be
# our value 'not_filtered'
```
</div><div>

* it's possible that a developer is using a GET form, then a POST form. In such scenario, the (lazy?) developer may use `$_REQUEST` to fetch values. If the dev checked the data at step1, but not at step2, we may be able to bypass the check in step1.

```bash
$ curl 'URL/step1?param=verified'
# the dev ensure param is verified
# verify_or_reject_param($_GET)
# now, the dev may "trust" param to be valid
$ curl 'URL/step2?param=verified' -d 'xxx=yyy&param=unverified'
# the dev filter $_POST: filterXXX($_POST)
# the dev uses $_REQUEST['param']
# but, it's our unverified value that is used
```
</div></div>