<hr class="sep-both">

## Logic Flaw

[![authenticationbypass](../../../_badges/thmp/authenticationbypass.svg)](https://tryhackme.com/room/authenticationbypass)

<div class="row row-cols-md-2"><div>

In PHP, there is a variable `$_POST` to fetch the input fields send to the server using POST, and `$_GET` for input fields send using GET. There is another prefilled variable: `$_REQUEST` which contains both values in `$_GET`, and values in `$_POST`.

If a value is both in `$_POST`, AND `$_GET`, then ONLY the value in `$_POST` will be kept. This is worth mentioning, because

* a developer might use `$_REQUEST` for a GET form, instead of `$_GET`. In such case, we may be able to inject data using POST, so that even if the data send using GET is filtered, we may bypass these filters.

```bash
$ curl 'URL?param=value' -d 'param=not_filtered'
# the dev filter $_GET: filterXXX($_GET)
# but in $_REQUEST['param'], there will be
# our value 'not_filtered'
```
</div><div>

* it's possible that a developer is using a GET form, then a POST form. In such scenario, the (lazy?) developer may use `$_REQUEST` to fetch values. If the dev checked the data at step1, but not at step2, we may be able to bypass the check in step1.

```bash
$ curl 'URL/step1?param=verified'
# the dev ensure param is verified
# verify_or_reject_param($_GET)
# now, the dev may "trust" param to be valid
$ curl 'URL/step2?param=verified' -d 'xxx=yyy&param=unverified'
# the dev filter $_POST: filterXXX($_POST)
# the dev uses $_REQUEST['param']
# but, it's our unverified value that is used
```
</div></div>