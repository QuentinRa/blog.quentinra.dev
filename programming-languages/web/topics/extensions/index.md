# Browser plugins/extensions

<div class="row row-cols-lg-2"><div>

You can add extensions/plugins to your browser, for instance, [DarkReader](https://darkreader.org/) or [uBlock](https://ublockorigin.com/). It's quite easy to write your own! üöÄ

**Where to learn?** üè´

* [Chrome extensions](https://developer.chrome.com/docs/extensions/mv3/) + [API reference](https://developer.chrome.com/docs/extensions/reference/) + [Examples](https://github.com/GoogleChrome/chrome-extensions-samples)
* [Firefox extensions](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions) + [Examples](https://github.com/mdn/webextensions-examples) (üëª)
* [Microsoft Edge extensions](https://learn.microsoft.com/en-us/microsoft-edge/extensions-chromium/) (üëª)
</div><div>

There are a few differences between Firefox and Chrome. The main difference is that in **Chrome** üåè you will use

```text!
chrome.xxx.yyy
```

While inside **Firefox** ü¶ä, you will use

```text!
browser.xxx.yyy
```
</div></div>

<hr class="sep-both">

## üêç Extension Workflow üêç

<div class="row row-cols-lg-2"><div>

#### Add a local extension üöÄ

<p></p>

* **Edge**: Go to `edge://extensions/`, enable `Developer mode`, click on `Load unpacked`, and select the folder with your `manifest.json`.

* **Chrome**: Go to `chrome://extensions`, enable `Developer mode`, click on `Load unpacked`, and select the folder with your `manifest.json`.

* **Firefox**: to load a packed extension <small>(zip)</small>, use: `about:addons` <small>(settings > install from file)</small>, otherwise, use `about:debugging#/runtime/this-firefox`. The latter are unloaded after closing the browser.

#### Track errors/logs üêõ

On the page where you added your extension

* you can see every error generated by your extension.
* you can open the console associated with your `service_worker`

To debug a script loaded by your `popup.html`, right-click on your extension in the toolbar, and use `Inspect`/`Inspect [...]`.
</div><div>

#### Reloading an extension üí™

You have to (manually) reload the extension if you edited

* üëâÔ∏è The Manifest
* üëâÔ∏è Any script <small>(+ refresh the page)</small>

But, you don't need to if you only edited an HTML file.

* Go to your plugin page
* Use a `refresh`/`reload` button to reload your extension

<details class="details-e">
<summary>Automatically reload the extension</summary>

* Use a (good) template
* Try [chrome-extensions-reloader](https://github.com/arikw/chrome-extensions-reloader) (üëª)
* Call `chrome.runtime.reload()` <small>(not available in a content_script)</small>.
</details>
</div></div>

<hr class="sep-both">

## üì¶ Templates üì¶

<div class="row row-cols-lg-2"><div>

Extension Templates can make working with extensions easier.

* ‚ú® These can preconfigure React/Typescript/...
* ‚ú® These can reload automatically the extension
* ...

#### My "Hello, World"

<p></p>

<details class="details-n">
<summary>console.log("Hello, World")</summary>

* Create `manifest.json`

```json!
{
  "name": "Hello, World",
  "version": "0.0.1",
  "manifest_version": 3,
  "description": "Print \"Hello, World\" in the console",
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["scripts/main.js"]
    }
  ]
}
```

* Create `scripts/main.js`

```javascript!
console.log("Hello, World")
```

* Load your extension
* Visit a website, open the console, and you will see the log
</details>
</div><div>

#### chrome-extension-typescript-starter

[GitHub](https://github.com/chibat/chrome-extension-typescript-starter) (1.2k ‚ú®, React, Typescript, Jest)

<details class="details-n">
<summary>See my notes</summary>

‚û°Ô∏è **Get started**

```shell!
$ git clone https://github.com/chibat/chrome-extension-typescript-starter.git my-extension
$ cd .\my-extension\
$ npm install
$ npm update
$ npm run watch
```

‚û°Ô∏è **Bootstrap**

To load bootstrap, download it locally, and store it inside a directory in `public` (ex: lib/). Then in `popup.html`, use

```xml!
<link href="lib/css/bootstrap.min.css" rel="stylesheet">
<script src="lib/js/bootstrap.bundle.min.js"></script>
```

‚û°Ô∏è **MANIFEST**

For JS files in the Manifest, `src/*.ts` will generate a file `js/*.js`.

```json!
"background": {
  "service_worker": "js/background.js"
},
"content_scripts": [
  {
    "matches": ["http://localhost/:*/"],
    "js": ["js/content_script.js"]
  }
],
```
</details>
</div></div>

<hr class="sep-both">

## üé∫ Manifest.json üé∫

[See Manifest.json](https://developer.chrome.com/docs/extensions/mv3/manifest/)

<div class="row row-cols-lg-2"><div>

This is a JSON file defining your extension. Version 2 is being deprecated, consider using version 3. üöÄ

```json!
{
  "manifest_version": 3
  ...
}
```

<details class="details-n">
<summary>Metadata: <code>description</code>, <code>version</code>, <code>name</code>, and <code>icons</code></summary>

The `name`, the `description`, and the `version` are up to you.

```json!
  "name": "Hello, World",
  "version": "0.0.1",
  "description": "Print \"Hello, World\" in the console",
```

You should provide an icon in multiple sizes: `16`, `32`, `48` and `128`. The browser will do the resizing for missing resolutions.

```json!
  "icons": {
    "16": "icons/hello_world_16.png",
    "32": "icons/hello_world_32.png",
    "48": "icons/hello_world_48.png",
    "128": "icons/hello_world_128.png"
  }
```
</details>
</div><div>

Then, you can define your extension

* ‚û°Ô∏è `action`: open a popup when clicking on the icon in the toolbar
* ‚û°Ô∏è `content_scripts`: to run code on each page using the DOM
* ‚û°Ô∏è `background`: to run code that does not need to access the DOM
* ‚û°Ô∏è `options_ui`: a page to configure the extension

‚ö†Ô∏è Inside a `content_scripts`, most of the attributes of `chrome`/`browser` extension variable **aren't** available. Moreover, some properties are only available after asking for [permission](https://developer.chrome.com/docs/extensions/mv3/declare_permissions/) first using both:

```json!
  "host_permissions": [ "<all_urls>" ], // OR, add URLs here
  "permissions": ["activeTab"]
```

‚ú® Usually, the permission `xxx` grants access to `browser.xxx`.
</div></div>

<hr class="sep-both">

## Popup

üëâ One of the changes from Manifest V2 to Manifest V3 is `browserAction` being renamed `action` both in the Manifest, and in the code.

<div class="row row-cols-lg-2"><div>

It's possible to show a popup when the user clicks on the icon in the toolbar, which is called **badge**. You can do it inside the Manifest

```json!
  "action": {
    "default_popup": "popup/popup.html",
    "default_icon": "icons/hello_world_16.png" // optional
  }
```

Or, at any time, inside the code

```javascript!
chrome.action.setPopup({ popup: "popup/popup.html" })
```

<details class="details-e">
<summary>popup.html</summary>

This is an [HTML](../../html/index.md) page as you would create for websites.

```html!
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hello, World</title>
</head>
<body>
<div>
    <p>Hello, World</p>
    <!-- load popup/popup.js -->
    <script src="popup.js"></script>
</div>
</body>
</html>
```
</details>

Note that the code inside the Popup is **only** executed when the popup is shown.

<br>

#### Execute some code

If you don't open a popup, it's also possible to register a listener, and execute some code when the user clicks on the badge.

```javascript!
// ‚û°Ô∏è When users click on the badge
// ‚û°Ô∏è When users use the shortcut (if any)
chrome.action.onClicked.addListener((tab) => {});
```
</div><div>

#### Badge

The icon inside the toolbar is called a `badge`. You can add a text next to it, like the number of ads blocked on the current tab.

```javascript!
// ‚û°Ô∏è Inside popup.html/popup.js/...
badge.textContent = `XXX`;
// ‚û°Ô∏è Otherwise,
chrome.action.setBadgeText({ text: "xxx", });
chrome.action.setBadgeText({ tabId: tab.id, text: "yyy", });
chrome.action.getBadgeText({ tabId: tab.id });
```

#### Shortcut

To add a shortcut to open the badge, add to your MANIFEST:

```json!
  "commands": {
    "_execute_action": {
      "suggested_key": {
        "default": "Ctrl+M",
        "mac": "Command+M"
      }
    }
  }
```
</div></div>

<hr class="sep-both">

## Content scripts

<div class="row row-cols-lg-2"><div>

Content scripts are used if you want your extension to interact with the **DOM** of the loaded page, for instance, to inject some code.

```json!
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["scripts/main.js"]
    }
  ]
```

The attribute `matches` takes patterns such as `https://example.com/*`. ‚û°Ô∏è [Refer to the match patterns documentation.](https://developer.chrome.com/docs/extensions/mv3/match_patterns/)
</div><div>

#### web_accessible_resources

If you need to access a resource stored inside the plugin folder, first, declare the resource inside the Manifest

```json!
  "web_accessible_resources": [
    {
      "matches": ["<all_urls>"],
      "resources": ["xxx"]
    }
  ]
```

Then, use `chrome.runtime.getURL("xxx")` to get a URL to it.
</div></div>

<hr class="sep-both">

## Additional Components

<div class="row row-cols-lg-2"><div>

#### Background and Service Worker

Service workers can be stopped, and started when an event occurs. They are useful for long-running tasks, or to access the Chrome/Firefox API without having to use a popup.

```json!
  "background": {
    "service_worker": "background.js"
  },
```
</div><div>

#### Option Page

You can create an option page to allow user to customize the extension. We usually save these settings in the `storage.sync` storage.

```json!
  "options_ui": {
    "page": "options.html",
    "open_in_tab": true
  },
```
</div></div>

<hr class="sep-both">

## Chrome/Firefox API

‚ö†Ô∏è Reminder: most of these are only available inside a background script, or a script executed by your popup. ‚ö†Ô∏è

<div class="row row-cols-lg-2"><div>

üéØ Just so you know, you can use `async`/`await` instead of callbacks. You can use this trick if you're not able to use `await`:

```javascript!
(async () => {
    const [tab] = await chrome.tabs.query({/*...*/});
    // ...
})();
```

#### Tabs

<p class="mt-3"></p>

<details class="details-n">
<summary><code>chrome.tabs.query</code>: fetch a tab, such as the active tab</summary>

```javascript!
// ‚û°Ô∏è ex: popup.js
chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
    const url = tabs[0].url;
    const title = tabs[0].title;
    const id = tabs[0].id
    // ...
})
chrome.tabs.query({ active: true, lastFocusedWindow: true }, function (tabs) {})
chrome.tabs.query({ url: [] }, function (tabs) {})
```
</details>

<details class="details-n">
<summary><code>chrome.tabs.create/update</code>: create/update a tab</summary>

```javascript!
// üîê "tabs"
await chrome.tabs.create({ url: "URL" })
await chrome.tabs.update(tab.id, { active: true });
await chrome.windows.update(tab.windowId, { focused: true });
```
</details>

<details class="details-n">
<summary><code>chrome.tabGroups/update</code>: group tabs</summary>

```javascript!
// üîê permission "tabGroups"
const group = await chrome.tabs.group({ tabIds });
await chrome.tabGroups.update(group, { title: "xxx" });
```
</details>

#### Scripting

<p class="mt-4"></p>

<details class="details-n">
<summary><code>insertCSS/removeCSS</code>: manipulate the CSS</summary>

```javascript!
// üîê permission "scripting"
chrome.scripting.insertCSS({ files: ["focus-mode.css"], target: { tabId: tab.id },});
chrome.scripting.removeCSS({ files: ["focus-mode.css"], target: { tabId: tab.id },});
```
</details>

#### Download

<p class="mt-4"></p>

<details class="details-n">
<summary>Generate a link for a JSON in a content script</summary>

```javascript!
const content : any = JSON.stringify( { "message": "ok" }, null, 2);
const url = URL.createObjectURL( new Blob([content], {type: 'application/json'}) );
```
</details>

<details class="details-n">
<summary>Generate a link for a JSON in a background script</summary>

I couldn't find anything. This works, but the indentations, the spaces, and most of the generated JSON is messed up.

```javascript!
const url = 'data:application/json,' + JSON.stringify(/*...*/)
```

The only workaround is to add a comment with `//?` at the start of the JSON.

```javascript!
const url = 'data:application/json,//?\n' + JSON.stringify(/*...*/)
```
</details>

```javascript!
// üîê permission "downloads"
chrome.downloads.download({ url, filename: "xxx.json" });
chrome.downloads.download({ url, filename: "...", saveAs: true });
```
</div><div>

#### Store/Load data

[Storage - reference](https://developer.chrome.com/docs/extensions/reference/storage/). See also [Storage Area Explorer](https://stackoverflow.com/questions/11922964/how-do-i-view-the-storage-of-a-chrome-extension-ive-installed).

<details class="details-n">
<summary>Use <code>storage.local</code></summary>

```javascript!
// üîê permission "storage"
// Get
chrome.storage.local.get(["key"], function(result){
    const value = result["key"]
    // ...
})
// Set
chrome.storage.local.set( { key: value } ).then(() => {})
// Dump
chrome.storage.local.get(function(result) { console.log(result) })
// Clear
chrome.storage.local.clear()
```
</details>

<details class="details-n">
<summary>Dynamic keys</summary>

If the key is from a variable, use the code below

```javascript!
// Dynamic keys
const key = "key"
const entry = {}
entry[key] = value
chrome.storage.local.set(entry).then(() => {})
```

</details>

#### Bookmarks

[Bookmarks - reference](https://developer.chrome.com/docs/extensions/reference/bookmarks/).

<details class="details-n">
<summary>Get/Remove/...</summary>

```javascript!
// get
chrome.bookmarks.getChildren("id", function(result) {})
chrome.bookmarks.get("id", function(result) {})
// remove
chrome.bookmarks.remove("id")
chrome.bookmarks.removeTree("id")
```
</details>

<details class="details-n">
<summary>Events - created, updated, removed</summary>

```javascript!
function cb(id, info) {}
// { "dateAdded": 0, "id": "0", "index": 0, "parentId": "0", "title": "xxx", "url": "xxx }
chrome.bookmarks.onCreated.addListener(cb)
// { "title": "xxx", "url": "xxx" }
chrome.bookmarks.onChanged.addListener(cb)
chrome.bookmarks.onMoved.addListener(cb)
// { "index": 0, "node": { "dateAdded": 0, "id": "0", "title": "xxx", "url": "xxx" }, "parentId": "0" }
chrome.bookmarks.onRemoved.addListener(cb)
```
</details>

#### Utilities

<p class="mt-4"></p>

<details class="details-n">
<summary><code>sendMessage</code>: send messages to content scripts</summary>

To send a message from a background script/popup

```javascript!
// ‚û°Ô∏è Sender - ex: popup.js
chrome.tabs.sendMessage(tabs[0].id,
    { /* custom data */ },
    function(response) { /* ... */}
);
```

Inside a content script, you can use

```javascript!
chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
    // ...
    sendResponse({ /* custom */ });
});
```
</details>

<details class="details-n">
<summary><code>onInstalled</code>: run some code after installing the extension</summary>

```javascript!
chrome.runtime.onInstalled.addListener(() => {});
```
</details>
</div></div>

<hr class="sep-both">

## Additional Notes For Firefox Extensions

<div class="row row-cols-lg-2"><div>

You can get started by using the [chrome-extension-typescript-starter](#chrome-extension-typescript-starter) template. Replace `chrome` with `browser` and update `package.json`.

```diff
-    "build": "webpack --config webpack/webpack.prod.js",
+    "build": "webpack --config webpack/webpack.prod.js && cd dist && npx web-ext build",
```

```diff
  "dependencies": {
     ...,
+    "web-ext": "^X.X.X"
  }
  "devDependencies": {
-    "@types/chrome": "X.X.X",
+    "@types/firefox-webext-browser": "^X.X.X",
     ...
  }
```

The ZIP will be built in `dist/web-ext-artifacts/`.
</div><div>

You will also have to add an ID in your extension manifest:

```json!
{
 "browser_specific_settings": {
    "gecko": {
      "id": "{aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa}"
    }
  },
  ...
}
```

To test a non-signed extension, you must use [Firefox Developper](). Refer to [this StackOverflow thread](https://stackoverflow.com/questions/62237202/firefox-add-ons-how-to-install-my-own-local-add-on-extension-permanently-in-f) to set the following variables:

```text!
extensions.langpacks.signatures.required
xpinstall.signatures.required
```
</div></div>

<hr class="sep-both">

## üëª To-do üëª

Stuff that I found, but never read/used yet.

<div class="row row-cols-lg-2"><div>

* [Polyfill](https://github.com/mozilla/webextension-polyfill)
* [plasmo](https://github.com/PlasmoHQ/plasmo) / [chrome-types](https://www.npmjs.com/package/chrome-types)

```javascript!
chrome.contextMenus.create({ id: "xxx", title: "xxx", contexts: ['selection'] });
chrome.contextMenus.onClicked.addListener(function(info, tab) {
    if (info.menuItemId == "xxx") {     
        const word = info.selectionText;
        // ...    
    }
});
```
</div><div>

```javascript!
document.addEventListener("pageshow", xxx);
```
</div></div>