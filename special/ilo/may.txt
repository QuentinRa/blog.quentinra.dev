je sais pas pour une méthode, mais si tu veux faire l'aventurière alors tu peux essayer de les chercher dans le code du prof, il en utilise pas mal.
En gros, tu vois tes questions du tp de chat ? (reponses.md) bah dans les endroits qu'il te faisait visiter, tu
pouvais observer certains design patterns. Sachant qu'on apprends pas un design pattern, il faut uniquement formater
 tes yeux pour le reconnaitre lorsque tu vois un bout de code :sparkles:

Donc bah tu fais un fiche de note sur ce que t'as capté de certains design pattern (pas trop compliqué,
mais uniquement avec les slides du prof tu vas galérer, check les tutos sur internet mdrrr). Ensuite tu tests
 tes yeux, par exemple sur le code du prof.

Sinon niveau design pattern je suis presque sûr qu'un confrère iiens à déjà fait une fiche de synthèse, faut
 juste le ou la trouver :uwu:

Mais bon c'est un forceur le prof, généralement tu utilises en OO environ 5-10 de tous les design patterns
 au quotidien donc pas trop utilise de formater ces yeux pour les 23 d'un coup, c'est un peu trop chaud.
 Parce que le meilleur moyen de comprendre un design pattern est de faire des projets, genre galérer puis
 voir en fait que un design pattern t'aurait simplifié la vie à mort et dans ta dépression, tu vas retenir
 que le design pattern etc. jusqu'à en connaitre pleins

 Genre un jour tu coderas probablement dans un IDE et tu te rendras compte que "ah bin j'ai passé plein de
 temps à débug mon TP Chat" alors qu'en fait dans un IDE ça se fait en quelques heures et dans ta soufrance
 tu arrêteras d'utiliser un éditeur de texte=eclipse pour coder du Java (instant salé non demandé et pas en
  rapport avec le reste :sip:)

As a side note: GoF = https://www.gofpatterns.com/ c la ref du cours hein

1. mémorise pour chaque patron ce qu'il fait dans les grandes lignes
2. essaye de travailler pour depuis 1., te rappeler comment le design pattern est implémenté (donc pas du par coeur ette fois, de la déduction)

L'objectif c'est depuis un UML de donner les DP donc pour ce faire tu dois probablement écrire sur ton brouillon les phrase des 23 DP. Puis pour chacun tu vas utiliser 1. puis 2. et regarder s'il est dans l'UML. ça va être du travail avec des yeux, mais le plus important est donc de bien créer 23 phrases pour te rappeler les 23 patrons, et ces phrases devront être assez parlantes pour qu'en les lisant tu te souviennent de quelques "forme" avait ce patron en UML genre par exemple

- Singleton : on veut une instance d'une classe, méthode static "isInstance" et attribut static du type de la classe

et maintenant dans le contrôle, tu vas regarder dans toutes les classes si ya des attributs static et si oui tu regardes si ça corresponds au singleton.
puis après patron suivant etc. jsk avoir fait les 23. Peut être un peu long, mais la méthode est très fiable mdrrr si tu veux y arriver facilement sans reposer sur ta chance :sparkles:
oui j'ai passé 2 ou 3 jours dessus je crois, fin j'ai finit par câbler :rofl: :sob:
genre je faisais une fiche par patron + le code Java puis après je faisais plus le code et après les dernières fiches étaient quasiment vides :madman: :pensive:
donc dernier conseil, essaye de pas tous les faire, prends tous les + connus et plus utilisés (genre ceux avec l'étoile dans ses slides) genre en avoir 10-12 c'est déjà pas mal :ok_hand:

c'est assez compliqué je trouve :uwu: :sparkles:.

En gros t'as une factory/abstract factory c'est des trucs qui vont créer des trucs.

Montre + Humain c'est ce que tu veux créer. T'as des sous-classes Gobelin, Troll … et Héros, PNJ mais ça tu veux pas le montrer. C'est le boulot d'une Factory ça.

Tu créé une AbstractFactory avec deux méthodes : créer monstre et créer humain.
Deux factory qui extends AbstractFactory, et chacune code l'un des deux méthodes genre MonstreFactory et HumainFactory et du coup ils font leur boulot à savoir retourner un héros/monstre.

(code théorique pour l'idée d'une Factory)
public class MonstreFactory extends AbstractFactory  {

    @Override
    Monstre createMonster(String monster) {
        switch (monster){
            case "serpent": return new Serpent();
            case "gobelin": return new Gobelin();
            // ...
        }
        return null;
    }

    @Override
    Human createHuman(String human) {
        throw new UnsupportedOperationException("not supported by this kind of factory");
    }
}


Tu créé une classe genre UnitCreator qui retourne une AbstractFactory (donc on sait même pas quellle factory on manipule c'est pour ça que chaque factory extends AbstractFactory) et genre on peut appeler dessus créer monstre et créer humain.

Tu viens donc de cacher les factory + les sous-classes.

Donc en gros abstract factory se résume à utiliser une classe abstraite pour cacher les factory et les factory se résume à faire des classes abstraites pour cacher les sous-classes :uwu:

C'est pour ça qu'on dit souvent qu'une abstract factory c'est qu'une factory (mais de d'autres factory).
