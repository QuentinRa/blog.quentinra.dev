Selon un article dans les références et ma compréhension de celui-ci, vous
pouvez calculer la vraisemblance en R pour une loi de bernouilli de la façon
suivante

.. code:: R

		# returns likehood
		L_bern <- function(r,n,expected){ return(dbinom(r,n,expected)) }
		# will be used to test the likehood for a lot of probabilities (expected)
		generate_L_bern <- function(expected){
		 n <- 10
		 p <- 0.7
		 r <- rbinom(1, n, p)
		 return(L_bern(r, n, expected));
		}
		# maximum likehood
		optimise(generate_L_bern, maximum = TRUE, interval = c(0,1))

7. Doxygen (enhanced)
==========================

Honnêtement, je trouvais que j'écrivais trop de documentation, et en plus l'interface
était moche, donc j'ai cherché à faire un truc beau, et au final j'arrive
à avoir une donc sans warnings mais qui est belle et avec moins de documentation
dans le code. Un exemple sont les \param devant un struct qui en fait sont facultatifs
mais cela rendait la doc plus claire de les mettre dans la version normale.

Il faudra installer doxygen, et télécharger

	* sur `https://github.com/mosra/m.css <https://github.com/mosra/m.css>`_
	* le dossier documentation/templates
	* le fichier documentation/__init__.py
	* le fichier documentation/_search.py
	* le fichier documentation/doxygen.py
	* le fichier documentation/favicon-dark.png
	* le fichier documentation/favicon-light.png
	* le fichier documentation/python.py
	* le fichier documentation/search.js
	* le contenu du dossier plugins (les 4 scripts .py) à mettre dans le dossier style (voir ci-après)
	* le dossier css
	* et personnellement j'ai tout mis dans le dossier style à la racine du projet
	* donc j'ai par exemple /style/css ou /style/dot2svg.py
	*

		si vous avez mis css dans style, alors il faut éditer dans doxygen.py deux lignes
		et remplacer :code:`../css/......` par :code:`css/........`.


Ensuite, voici les étapes

	* si pip n'est pas installé, sous linux :code:`sudo apt-get install python3-pip`
	* :code:`pip3 install jinja2 Pygments`
	*
		créer un DoxyFile par exemple DoxyCSS à la racine

		.. code::

				# used to become a god
				# style\doxygen.py DoxyCSS
				# inclut le Doxyfile original
				@INCLUDE                = Doxyfile
				# faits des modifications (faut pas modifier ces lignes normalement)
				GENERATE_HTML           = NO
				GENERATE_LATEX          = NO
				GENERATE_XML            = YES
				XML_PROGRAMLISTING     = NO
				XML_NS_MEMB_FILE_SCOPE = YES

	* si vous êtes sous linux : :code:`chmod +x style/doxygen.py`
	* ensuite vous faites :code:`style\doxygen.py DoxyCSS` (ou / sous linux)
	* la doc html/latex/... est au même endroit que d'habitude

Les points que j'ai notés

	* vous devez ajoute :code:`\dir` pour que vos fichiers soit ajoutés dans Files
	*

		vous pouvez créer des fichiers :code:`package.dox` (peu importe le nom mais package c'est bien)
		pour décrire un dossier (faites le d'abord dans un fichier puis avant de râler parce
		que ça copie la desc de chaque fichier dans la description du dossier, testez ça).
		Notez qu'en C++ ou en PHP, il suffit de remplacer dir par namespace

		.. code::

				/** @dir headers

				\authors ...
				\date 08/03/2021

				Une description du dossier
				*/

Vous pouvez modifier la barre de recherche avec un conf.py ou alors
avec les options doxyfile (notez que une_page.html est dans le nom
du .html généré à la toute fin dans votre dossier html/)

.. code::

		M_LINKS_NAVBAR1 = \
				"<a href=\"une_page.html\">User documentation</a>" \
				"annotated"
		M_LINKS_NAVBAR2 = \
				"files" \
				"<a href=\"une_page.html\">Fonctions</a>" \
				"<a href=\"un_lien">GitHub</a>"


1. Décrire précisément son comportement

(la réponse a cette question se trouve dans le poly du cours mais je n'ai pas recopié car
ce n'était pas **précisément** détaillé...)

Main

	Le programme créé deux pipes : :code:`pos`, :code:`neg`, si la création échoue alors on affiche
	un message sur la sortie d'erreur et on quitte avec le code 1.

	On créé un fils (stock son id dans :code:`pid_pos`) et on ferme l'écriture des deux pipes dans le fils.
	On appelle une fonction :code:`fils` avec le pipe pos en lecture.

	Si on a échoué a créé un fils ou on est dans le père, on réessaye une fois (sauf que on stoke l'id dans :code:`pid_neg`).

	Si on a échoué a créé un fils ou on est dans le père, on refait pareil sauf qu'on appelle  :code:`fils` avec le
	pipe neg en lecture.

	Si on a échoué a créé un fils ou on est dans le père alors on appelle une fonction  :code:`pere`.

	Enfin on affichera "argh!!!" dans le père, seulement si la fonction père n'a pas quitté le programme (et on
	retourne le code d'erreur 255).

Fils
	Les fils vont lire dans leur pipe donné (donc deux vont lire dans pop et un dans neg) et lorsqu'il n'y a plus rien
	a lire alors le fils quitte. (les messages sont de la forme "filsP:pid:nombre_lu" (et filsP est remplacé par filsN
	pour le pipe neg).

Pere
	Le père demande un entier tant que le flux n'est pas terminé (EOF).

	Si l'entier est positif, alors le père écrit sur le pip pos, et donc l'un des fils va afficher la valeur.

	Si l'entier est négatif, alors le père écrit sur le pip neg, et donc le fils associé va afficher la valeur.

	Si l'entier vaut 0, alors le père attends ses fils puis meurt.

2. Expliquer comment le modifier pour créer 3 fils qui impriment respectivement
les entiers congrus à 0, 1 et 2 modulo 3

On a déjà trois fils, on va créer 3 pipes (variables globales).

.. code:: c

	int zero[2];
	int un[2];
	int deux[2];

Dans le main

.. code:: c

	if ( pipe(zero) < 0 || pipe(un) < 0 || pipe(deux) < 0){
	 ... (aucun changement) ...
	}

Dans chaque fils on close les 3 pipes avant d'appeler la fonction fils. Voici un exemple
dans filsZero.

.. code:: c

	if ( (pid_zero=fork())==0 ){
	 close(zero[1]);
	 close(un[1]);
	 close(deux[1]);
	 fils("filsZero", zero[0]);
	}

On change les conditions

.. code:: c

    // if( x == -1 ) break; // pas demandé donc commenté mais peut être utile pour remplacer le x == 0 d'avant
    if( x % 3 == 0) write(zero[1],&x, len);
    if( x % 3 == 1) write(un[1],&x, len);
    if( x % 3 == 2) write(deux[1],&x, len);

On ajoute un wait_verbose pour le 3e fils

.. code:: c

    waitverbose(0); //zero
    waitverbose(0); //un
    waitverbose(0); //deux
    exit(0);

La logique est pareil, on confie le travail du cas 0 a un fils, du cas 1 à un autre et du cas 2 au dernier.
On lit dans le père, et si on écrit le nombre lu dans le pipe associé a notre cas après avoir vérifié
le modulo (nombre%3). Enfin on attends maintenant 3 fils avant de quitter.

On peut ajouter -1 par exemple pour quitter dans la boucle.