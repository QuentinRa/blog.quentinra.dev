# SQL injection (SQLi)

[Go back](../../index.md)

[![sqlinjectionlm](../../../../_badges/thm/sqlinjectionlm.svg)](https://tryhackme.com/room/sqlinjectionlm)
[![sqlilab](../../../../_badges/thm/sqlilab.svg)](https://tryhackme.com/room/sqlilab)
[![sqlinjectionfundamentals](../../../../_badges/htb/sqlinjectionfundamentals.svg)](https://academy.hackthebox.com/course/preview/sql-injection-fundamentals)
[![SQL Injection](../../../../_badges/poat/sql_injection.svg)](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)
[![sql-injection-payload-list](../../../../_badges/payloadbox/sql_injection.svg)](https://github.com/payloadbox/sql-injection-payload-list)

<div class="row row-cols-md-2"><div>

Most websites are using a [relational database](/programming-languages/databases/relational/_knowledge/index.md) to store data, and the [SQL](/programming-languages/databases/relational/sql/index.md) query language to query the database.

When making a SQL request, a programmer may use the user input. For instance, a product name for a query to search a product.

A vulnerable [PHP](/programming-languages/web/php/_general/index.md) code use the user input directly in the SQL request:

```php!
$name = $_GET['name']; // filled by the user
$sql = "Select name from product where name LIKE '%$name%'";
```

There is a SQL injection when a user inputs SQL code, and the request interpret the user input as SQL code.

‚úÖ If the user enters the product name "`yummy`"


```sql!
Select name from product where name LIKE '%yummy%'";
```
</div><div>

‚ùå But, with the product name "`' UNION SELECT "hacked"-- -`", the injected SQL code is executed just fine.

```sql!
Select name from product where name LIKE '%' UNION SELECT "hacked"-- -%'
```

‚û°Ô∏è A hacker may be able to fetch/create/update/delete records!

üî• While SQL injections are known since 1998, they are still a frequent vulnerability found in applications. They are found in every language.

<br>

**Tools** ü§ñ

* [sqlmap](../../tools/sqlmap.md) (discovery+exploitation)
</div></div>

<hr class="sep-both">

## SQLi categories

<div class="row row-cols-md-2"><div>

**In-band SQLi** üé∏ is a category of SQLi attacks for those using the same channel to attack and to gather results.

* [Error-based](files/error_sqli.md)
* [Union-based](files/union_sqli.md)

</div><div>

**Blind/inferential SQLi** üó∫Ô∏è is a category of SQLi attacks for which we observe the application response to infer results.

* [Boolean-based](files/boolean_sqli.md)
* [Time-based](files/time_sqli.md)
* Out-of-band-based
* Voice-based
* Stacked queries-based
</div></div>

<hr class="sep-both">

## SQLi payloads

<table class="table table-bordered table-striped border-dark mt-3">
<thead>
<tr><th>Name</th><th>Expected SQL</th><th>Payload</th></tr>
</thead>
<tbody>

<tr><td>Usual PoC</td><td><code>Select [...] where xxx='here' [...]</code></td><td><code>'</code><br><small>The query will fail as there would be 3 quotes,<br> and that would confirm that an injection is possible.</small></td></tr>

<tr><td>NoPassword</td><td><code>Select [...] where username='here' AND password='...' [...]</code></td><td><code>' OR 1=1 -- -</code><br><small>The query will bypass the check of the password,<br>if it was made in the query.<br>We use 1=1 for maximum compatibility.</small></td></tr>

<tr><td>Input box String</td><td><code>Select [...] where xxx='here' [...]</code></td><td><code>' code -- -</code></td></tr>

<tr><td>Input box Non-String</td><td><code>Select [...] where xxx=here [...]</code></td><td><code>'' code -- -</code></td></tr>

<tr><td>Update</td><td><code>Update [...] set x='here',y=[...]</code></td><td><code>',x=(code),y='</code></td></tr>
</tbody></table>

<hr class="sep-both">

## SQLi mitigations üõ°Ô∏è

<div class="row row-cols-md-2 mt-3"><div>

* Use **prepared requests** (statements), they are ensuring that the parameters of your queries are not interpreted as SQL code

* **Input validation** or **escaping user input**: You can filter input, but you CAN'T rely on it, as your filter will _most likely_ be bypassed

* **Do not trust anyone** üìå. SQL injections may be delayed. You may do protect your login queries, but if the provided username is some SQL code, then any other request using the username may interpret it.
</div><div>

**By-pass/notes** üîè

* You can by-pass client side verifications by manually sending the form or directly interacting with the API (if any).

* For manual SQLi, you may use the HTML tags "names" in the form first, as they may be the name of the attributes in the database.
</div></div>

<hr class="sep-both">

## üëª To-do üëª

Stuff that I found, but never read/used yet.

<div class="row row-cols-lg-2"><div>

* [sqlinjection.net](https://www.sqlinjection.net/)
</div><div>
</div></div>