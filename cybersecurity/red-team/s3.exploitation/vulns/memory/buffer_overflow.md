# Buffer Overflow

[![stack_based_buffer_overflows_linux_x86](../../../../_badges/htb/stack_based_buffer_overflows_linux_x86.svg)](https://academy.hackthebox.com/course/preview/stack-based-buffer-overflows-on-linux-x86)

<div class="row row-cols-lg-2"><div>

Buffers overflows occur when a user is able to inject more data that the system can handle, resulting in an overflow.

By overriding data, the user may be able to control and modify the program behavior, such as executing malicious code.

A buffer overflow can be categorized in

* **Stack-based** Buffer Overflow ğŸ—ƒï¸
* **Heap-based** Buffer Overflow ğŸŒ±

</div><div>

Buffers overflows are less common nowadays, mostly due to the implementation of several security mechanisms.

* ğŸª¤ **Data Execution Prevention** (DEP): mark as "read-only" memory regions where user input is stored such as the stack
* ğŸ›£ï¸ **Address Space Layout Randomization** (ASLR): randomize where everything is stored to make ROP attacks harder
* xxx
* xxx

ğŸ“š IoT and Embedded devices are a common target as they often use low-level vulnerable languages such as `C` or `C++`.
</div></div>

<hr class="sep-both">

## Stack-based Buffer Overflow

[![stack_based_buffer_overflows_linux_x86](../../../../_badges/htb/stack_based_buffer_overflows_linux_x86.svg)](https://academy.hackthebox.com/course/preview/stack-based-buffer-overflows-on-linux-x86)

<div class="row row-cols-lg-2"><div>

#### Find An Attack Vector

Identify vulnerable functions such as the following C functions:

* `strcpy`
* `sprintf`
* `gets`/`fgets`
* `scanf`/`fscanf`
* `strcat`
* ...

#### Take Over The Instruction Pointer

When a program calls a function, it stores the instruction pointer (`EIP`/`RIP`) to the stack. We can exploit a buffer overflow to take it over.

All commands below inject a lot of `A` to stdin <small>(assuming stdin in the vulnerable vector)</small>. The ideal result is the program crashing with the message `0x41414141 in ?? ()` which means we took over the EIP.

```text!
(gdb) run <<< $(python2 -c "print '\x41' * 1000")
(gdb) run <<< $(python3 -c "print( '\x41' * 1000 )")
(gdb) run <<< $(perl -e 'print "\x41"x1000')
0x41414141 in ?? ()
```
</div><div>

#### Determine The Offset

We want to determine when did we override the EIP. Generate a pattern with metasploit. Run the program with the given bytes, note the EIP, and pass the EIP to metasploit to find the exact offset.

```shell!
$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000
$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0xYOUR_NEW_EIP
```
</div></div>

<hr class="sep-both">

## ğŸ‘» To-do ğŸ‘»

Stuff that I found, but never read/used yet.

<div class="row row-cols-lg-2"><div>

* `CVE-2021-3156` in sudo
* Attack: make the program crash (benign)
* Return Oriented Programming (ROP)
* `Heap => go from the 0x0 to 0xf. Start at the end of .bss in x86.`, `Stack => go from 0xf to 0x0`.
</div><div>

```
# disable ASLR
sudo echo 0 > /proc/sys/kernel/randomize_va_space
# compile 32-bit ELF binary (no DEP)
gcc xxx.c -o xxx -fno-stack-protector -z execstack -m32
gcc xxx.c -o xxx -fno-stack-protector -z execstack -m64
```
</div></div>