# File upload

[![uploadvulns](../../../_badges/thmp/uploadvulns.svg)](https://tryhackme.com/room/uploadvulns)
[![vulnversity](../../../_badges/thm-p/vulnversity.svg)](https://tryhackme.com/room/vulnversity)
[![rrootme](../../../_badges/thm-p/rrootme.svg)](https://tryhackme.com/room/rrootme)
[![startup](../../../_badges/thm-p/startup.svg)](https://tryhackme.com/room/startup)

<div class="row row-cols-md-2"><div>

It's common for websites to allow users to upload files such as an avatar. Unfortunately, in some cases, a hacker can upload malicious files such as a script leading to **Remote Code Execution** (RCE); which also means Remote Command Execution.

Usually, most websites have filters, but there are often logic flaws in the filtering, leading to malicious files bypassing them.
</div><div>

**Impact üí•**: the hacker can upload a web/bind/reverse shell, and may take full control of the machine using privilege escalation.

**Vectors**

* Forms
* FTP, if it's linked to the website folder, and we can upload files
</div></div>

<hr class="sep-both">

## Process

<div class="row row-cols-md-2 mt-4"><div>

**Identify the filters, the upload folder, the naming scheme...**

1. ‚úÖ Upload a valid file<br><span>&nbsp;</span>
2. üîç Look for the folder where the file was uploaded.
  * Try to determine the naming scheme <small>(ex: {time}-{filename}.png)</small>. You may have to use [forced browsing tools](/_cybersecurity/exploitation/web/fuzz/forced_browsing.md) if indexing was turned off.
  * Try to see the behavior if uploading a file with the same name<br><span>&nbsp;</span>
3. ‚õî Try to upload a file that may be rejected<br><span>&nbsp;</span>
4. üîì If it was rejected, try a lot of payloads to see what the filter is using to assess whether a file can/can't be accepted. See the filter evasion section below. **Test your valid file with**
* the extension of the one that was rejected
* the MIME type of the one that was rejected
* the magic number of the one that was rejected
* ...<br><span>&nbsp;</span>

5. üí£ Try testing different file sizes to find the maximum upload size

> There may be JavaScript filters, and to be more efficient while making requests, I would advise using [Burp Suite](/_cybersecurity/exploitation/web/burpsuite/index.md#repeater-tab) Repeater.
</div><div>

You can also do the request manually:

```bash
# submit a file with name=file and value=path/to/file
$ curl -X POST -F "submit:value" -F "file:@path/to/file" URL
```

Sometimes, your web browser won't be able to open a file if you used a spoofed extension/MIME-type/... You can view the file contents with

```bash
$ curl invalid_file_that_my_browser_cant_open
```

**Remediation** üßØ

* Do not use a well-known name for your uploads (`uploads`, `images`...)

* Disable indexing

* Add a limit to the size of uploaded files (ex: in a `.htaccess`)

* Do not expose uploaded files if there is no reason for them to be available to the user. You could also restrict access with a `.htaccess` only allowing the local website to access them.

* Use multiple filters/ways to assess that a file is what you expect.

* Do not rely on HTML/JS filtering, as they can be bypassed
</div></div>

<hr class="sep-both">

## Filter evasion

*PHP functions that may be involved: `pathinfo`...*

<div class="row row-cols-md-2 mt-4"><div>

* ‚û°Ô∏è bypass check of the extension being in the filename

```
malicious.png.php
```

* ‚û°Ô∏è bypass blacklists/deny list

  * Other extensions that may have been enabled: `.php5`, `.phtml`, `.php2`, `.php3`, `.php4`,`.php7`, `.pht`, `.phps`, `.phar`, `.inc`...
  * Bypass case-sensitive filters, but the server may not execute them: `.pHp`, `.PHP`, `.PHTML`...<small>&nbsp;</small><br><br>

* ‚û°Ô∏è Try the null byte <small>(PHP < 5.3.4)</small>

```
malicious.php%00.png -> malicious.php
malicious.php\x00.png -> malicious.php
```

* ‚û°Ô∏è If there is a filter checking for the `<?php` tag, you can try
  * testing if the filter is case-sensitive: `<?PHP`, `<?pHP`...
  * testing  with another variant: `<?="xxx"?>`...

</div><div>

* ‚û°Ô∏è bypass  [MIME-type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types) checks by manually editing the `Content-Type` header of your request.

```
Content-Type: application/php -> image/png
```

* ‚û°Ô∏è An alternative to editing MIME-type is spoofing the file magic number. Using a command such as `file xxx`, you can see the type of your file. This is done by checking the first bytes of the file for a value called [magic numbers](https://en.wikipedia.org/wiki/List_of_file_signatures).

```bash
# Ex: use GIFs magic number (6 bytes: 47 49 46 38 37 61)
$ mv xxx.php xxx.gif
$ file script.gif # ASCII text
$ cat script.gif
 # add 6 dummy characters at the start
xxxxxx[...]
$ hexeditor script.png 
# replace them with the magic number
# 47 49 46 38 37 61
$ file script.gif # GIF
```
</div></div>

<hr class="sep-both">

## üëª To-do üëª

Stuff that I found, but never read/used yet.

<div class="row row-cols-md-2"><div>

* [Exif Data](https://null-byte.wonderhowto.com/how-to/bypass-file-upload-restrictions-web-apps-get-shell-0323454/)
* [Disable php extension](https://stackoverflow.com/questions/1271899/disable-php-in-directory-including-all-sub-directories-with-htaccess)
* [motasem-notes](https://motasem-notes.net/bypassing-php-disable-functions-and-upload-filters-tryhackme/)
* [File Magic Numbers](https://gist.github.com/leommoore/f9e57ba2aa4bf197ebc5)
</div><div>
</div></div>