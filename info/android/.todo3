* main activity: FragmentContainerView (ex id: nav_host_fragment,
name=androidx.navigation.fragment.NavHostFragment
"While you can specify a specific fragment for this attribute, setting it to NavHostFragment allows your
FragmentContainerView to navigate between fragments.")
Add defaultNavHost "true". This allows the fragment container to interact with the navigation hierarchy.
if the system back button pressed, then the container will navigate back to the previously shown fragment

dd an attribute called app:navGraph and set it equal to "@navigation/nav_graph".
This points to an XML file that defines how your app's fragments can navigate to one another.

because you added two attributes with the app namespace, be sure to add the xmlns:app attribute to the FrameLayout.
   xmlns:app="http://schemas.android.com/apk/res-auto

=> nav host widget: sort of cardlayout in Java

Navigation Controller
-----
private lateinit var navController: NavController
val navHostFragment = supportFragmentManager
    .findFragmentById(R.id.nav_host_fragment) as NavHostFragment
navController = navHostFragment.navController

setupActionBarWithNavController(navController)

Finally, implement onSupportNavigateUp(). Along with setting defaultNavHost to true in the XML,
 this method allows you to handle the up button. However, your activity needs to provide the implementation.

override fun onSupportNavigateUp(): Boolean {
   return navController.navigateUp() || super.onSupportNavigateUp()
}
-----
=> findNavController().navigate(dest_or_action_id)

SafeArgs plugin
=> generate classes based on navigation graph
=> XXXArgs
=> XXXDirections

val direction: NavDirections: ZZZDirections.actionXXXXToYYY()
val direction: NavDirections: ZZZDirections.actionXXXXToYYY( arg = value )
findNavController().navigate(direction)
"holder.view.findXXX"...

in a fragment
val args by navArgs<XXXArgs>()
val argName = args.argName
arguments?.let {
    letterId = it.getString(LETTER).toString()
}

Navigation UI
=> Options Menus, bottom nav, nav view, nav drawer, action bar, tool bar, collapsed tool bar
=> do "as normal", then setup with nav controller

https://developer.android.com/guide/navigation/navigation-getting-started
-----------

apps can listen to the data changes from the layout.
With Data Binding, when an observable LiveData value changes, t
he UI elements in the layout it's bound to are also notified,
and the UI can be updated from within the layout.

private lateinit var binding: ActivityMainBinding
binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
https://blog.logrocket.com/data-binding-android-tutorial-with-examples/
```gradle
buildFeatures {
    dataBinding = true
}
```

binding.textViewUnscrambledWord.text = viewModel.currentScrambledWord
https://developer.android.com/topic/libraries/data-binding

dataBinding = true INSTEAD OF viewBinding
To use data binding in any Kotlin project, you should apply the kotlin-kapt plugin.

binding = DataBindingUtil.inflate(inflater, R.layout.game_fragment, container, false)
<layout xmlns:android="http://schemas.android.com/apk/res/android"
   xmlns:app="http://schemas.android.com/apk/res-auto"
   xmlns:tools="http://schemas.android.com/tools">

   <data>
    <!-- binding.gameViewModel = viewModel -->
<variable
       name="gameViewModel"
       type="com.example.android.unscramble.ui.game.GameViewModel" />
       <variable
              name="maxNoOfWords"
              type="int" />
   </data>

   <!-- wrapped content

    android:text="@{gameViewModel.currentScrambledWord}"
    android:text="@{@string/example_resource(user.lastName)}"
    -->
</layout>

binding.lifecycleOwner = viewLifecycleOwner
binding.lifecycleOwner = this

------------
leanback in the manifest

----------------

https://coil-kt.github.io/coil/
If you got URL but ImageView slot
implementation "io.coil-kt:coil:1.1.1"
https://developer.android.com/codelabs/basic-android-kotlin-training-internet-images

----------------
Use dataBinding
https://developer.android.com/codelabs/basic-android-kotlin-training-internet-images