* onCreate => bundle
    => setHasOptionsMenu(true) ???
* onViewCreated()
* onDestroyView()
    => binding = null

Cannot use this, use requireContext(), when a context is needed
activity?.intent?
--------

Bottom Navigation
=> navigates, and you want the color to change,
handle "back-stack" (what is it?)

Navigation component is a collection of libs, and stuff simplifying android navigation.
=> navigation graph: view of screens (called destinations) linked by "action". Click on a screen to see options, args passed...
    There are deep links like in facebook.

screens+fragments that are called destinations
* main activity: FragmentContainerView (ex id: nav_host_fragment,
name=androidx.navigation.fragment.NavHostFragment
"While you can specify a specific fragment for this attribute, setting it to NavHostFragment allows your
FragmentContainerView to navigate between fragments.")
Add defaultNavHost "true". This allows the fragment container to interact with the navigation hierarchy.
if the system back button pressed, then the container will navigate back to the previously shown fragment

dd an attribute called app:navGraph and set it equal to "@navigation/nav_graph".
This points to an XML file that defines how your app's fragments can navigate to one another.

because you added two attributes with the app namespace, be sure to add the xmlns:app attribute to the FrameLayout.
   xmlns:app="http://schemas.android.com/apk/res-auto

* new res nav
* screen+ > pick frags
* arrow from one screen to another > add arguments if needed
* select a dest > click on home to Assign it as the start destination.
* property label for the "name of the screen"

=> nav host widget: sort of cardlayout in Java

Navigation Controller
-----
private lateinit var navController: NavController
val navHostFragment = supportFragmentManager
    .findFragmentById(R.id.nav_host_fragment) as NavHostFragment
navController = navHostFragment.navController

setupActionBarWithNavController(navController)

Finally, implement onSupportNavigateUp(). Along with setting defaultNavHost to true in the XML,
 this method allows you to handle the up button. However, your activity needs to provide the implementation.

override fun onSupportNavigateUp(): Boolean {
   return navController.navigateUp() || super.onSupportNavigateUp()
}
https://en.wikipedia.org/wiki/Short-circuit_evaluation
-----
=> findNavController().navigate(dest_or_action_id)

SafeArgs plugin
=> generate classes based on navigation graph
=> XXXArgs
=> XXXDirections

val direction: NavDirections: ZZZDirections.actionXXXXToYYY()
val direction: NavDirections: ZZZDirections.actionXXXXToYYY( arg = value )
findNavController().navigate(direction)
"holder.view.findXXX"...

in a fragment
val args by navArgs<XXXArgs>()
val argName = args.argName
arguments?.let {
    letterId = it.getString(LETTER).toString()
}

Navigation UI
=> Options Menus, bottom nav, nav view, nav drawer, action bar, tool bar, collapsed tool bar
=> do "as normal", then setup with nav controller

https://developer.android.com/guide/navigation/navigation-getting-started

-----------------

It's possible to have multiples "screens" within one activity, for instance tabs, using fragments. Fragments
are reusable view that can be embed in activities. For instance, a navbar will most likely be a fragment.
It fragment has it own lifecycle.

https://developer.android.com/reference/kotlin/androidx/lifecycle/Lifecycle.State
https://developer.android.com/codelabs/basic-android-kotlin-training-fragments-navigation-component#2

New fragment
tools:context if changing the .fxml

------------
https://developer.android.com/guide/navigation/navigation-getting-started
https://developer.android.com/guide/navigation/navigation-pass-data
https://developer.android.com/courses/pathways/android-basics-kotlin-unit-3-pathway-2#codelab-https://developer.android.com/codelabs/basic-android-kotlin-training-fragments-navigation-component

------

ViewModel, one of the Architecture components to store your app data. The stored data is not lost if the framework
destroys and re-creates the activities and fragments during a configuration change or other events.

onSaveInstanceState() -> extra code + too small

The main classes or components in Android Architecture are UI Controller (activity/fragment), ViewModel, LiveData and Room.
These components take care of some of the complexity of the lifecycle and help you avoid lifecycle related issues.

Controller
Draw on screen
capture events / stuff related to the UI
Can be destroyed at any time

ViewModel
Data, decision-making logic about that dat
app related data that isn't destroyed when activity or fragment is destroyed and recreated by the Android framework

// ViewModel
implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1'
https://developer.android.com/jetpack/androidx/releases/lifecycle

// create in the associated activity/fragment
private val viewModel: XXXViewModel by viewModels()
=>
Property delegation in Kotlin helps you to handoff the getter-setter responsibility to a different class.
This class (called delegate class) provides getter and setter functions of the property and handles its changes.
=> we are using this to avoid having a new instance created
Instead, use the property delegate approach and delegate the responsibility of the viewModel object to a separate class called viewModels.
That means when you access the viewModel object, it is handled internally by the delegate class, viewModels.
The delegate class creates the viewModel object for you on the first access, and retains its value through configuration changes and
 returns the value when requested.

Backing properties like in C#
 val count: Int
    get() = _count

A view model lives from the start until the activity is destroyed (#onCleared())
Add helpers in your view model, like getUserByID(XXX).

----------
Dialogs
* title (optional)
* message
* buttons

MaterialAlertDialogBuilder(requireContext())
.setTitle(getString(R.string.xxx))
.setMessage(getString(R.string.xxx))
.setCancelable(false) # not closable using back
.setNegativeButton(getString(R.string.xxx)) { _, _ ->
}
.setPositiveButton(getString(R.string.xxx)) { _, _ ->
}
.show()

-----------
TextInputLayout comes with a built-in functionality to display error messages.
xxx.error = getString(R.string.error)
xxx.error = null // clear
xxx.isErrorEnabled = true