* onCreate => bundle
    => setHasOptionsMenu(true) ???
* onViewCreated()
* onDestroyView()
    => binding = null

Cannot use this, use requireContext(), when a context is needed
activity?.intent?
--------

Bottom Navigation
=> navigates, and you want the color to change,
handle "back-stack" (what is it?)

Navigation component is a collection of libs, and stuff simplifying android navigation.
=> navigation graph: view of screens (called destinations) linked by "action". Click on a screen to see options, args passed...
    There are deep links like in facebook.

screens+fragments that are called destinations
* main activity: FragmentContainerView (ex id: nav_host_fragment,
name=androidx.navigation.fragment.NavHostFragment
"While you can specify a specific fragment for this attribute, setting it to NavHostFragment allows your
FragmentContainerView to navigate between fragments.")
Add defaultNavHost "true". This allows the fragment container to interact with the navigation hierarchy.
if the system back button pressed, then the container will navigate back to the previously shown fragment

dd an attribute called app:navGraph and set it equal to "@navigation/nav_graph".
This points to an XML file that defines how your app's fragments can navigate to one another.

because you added two attributes with the app namespace, be sure to add the xmlns:app attribute to the FrameLayout.
   xmlns:app="http://schemas.android.com/apk/res-auto

* new res nav
* screen+ > pick frags
* arrow from one screen to another > add arguments if needed
* select a dest > click on home to Assign it as the start destination.
* property label for the "name of the screen"

=> nav host widget: sort of cardlayout in Java

Navigation Controller
-----
private lateinit var navController: NavController
val navHostFragment = supportFragmentManager
    .findFragmentById(R.id.nav_host_fragment) as NavHostFragment
navController = navHostFragment.navController

setupActionBarWithNavController(navController)

Finally, implement onSupportNavigateUp(). Along with setting defaultNavHost to true in the XML,
 this method allows you to handle the up button. However, your activity needs to provide the implementation.

override fun onSupportNavigateUp(): Boolean {
   return navController.navigateUp() || super.onSupportNavigateUp()
}
https://en.wikipedia.org/wiki/Short-circuit_evaluation
-----
=> findNavController().navigate(dest_or_action_id)

SafeArgs plugin
=> generate classes based on navigation graph
=> XXXArgs
=> XXXDirections

val direction: NavDirections: ZZZDirections.actionXXXXToYYY()
val direction: NavDirections: ZZZDirections.actionXXXXToYYY( arg = value )
findNavController().navigate(direction)
"holder.view.findXXX"...

in a fragment
val args by navArgs<XXXArgs>()
val argName = args.argName
arguments?.let {
    letterId = it.getString(LETTER).toString()
}

Navigation UI
=> Options Menus, bottom nav, nav view, nav drawer, action bar, tool bar, collapsed tool bar
=> do "as normal", then setup with nav controller

https://developer.android.com/guide/navigation/navigation-getting-started

-----------------

It's possible to have multiples "screens" within one activity, for instance tabs, using fragments. Fragments
are reusable view that can be embed in activities. For instance, a navbar will most likely be a fragment.
It fragment has it own lifecycle.

https://developer.android.com/reference/kotlin/androidx/lifecycle/Lifecycle.State
https://developer.android.com/codelabs/basic-android-kotlin-training-fragments-navigation-component#2

New fragment
tools:context if changing the .fxml

----------
The main classes or components in Android Architecture are UI Controller (activity/fragment), ViewModel, LiveData and Room.
These components take care of some of the complexity of the lifecycle and help you avoid lifecycle related issues.

Controller
Draw on screen
capture events / stuff related to the UI
Can be destroyed at any time

-----------
TextInputLayout comes with a built-in functionality to display error messages.
xxx.error = getString(R.string.error)
xxx.error = null // clear
xxx.isErrorEnabled = true
-----------
LiveData is an observable data holder class that is lifecycle-aware (only update if started/resumed).
Just something observing changes in the model, and updating the view.

MutableLiveData is the mutable version of the LiveData
=> use LiveData as a type  LiveData<String> and MutableLiveData<String> (backed)
=> live_data_var.value
=> _currentWordCount.value!!
=> LiveData<Int>.value)?.plus(v)
=> LiveData<Int>.value)?.inc()

// Observe the live_data_var LiveData.
// viewLifecycleOwner -> as we are in a fragment
viewModel.live_data_var.observe(viewLifecycleOwner, { p ->
})

apps can listen to the data changes from the layout.
With Data Binding, when an observable LiveData value changes, t
he UI elements in the layout it's bound to are also notified,
and the UI can be updated from within the layout.

private lateinit var binding: ActivityMainBinding
binding = DataBindingUtil.setContentView(this, R.layout.activity_main)
https://blog.logrocket.com/data-binding-android-tutorial-with-examples/
```gradle
buildFeatures {
    dataBinding = true
}
```

binding.textViewUnscrambledWord.text = viewModel.currentScrambledWord
https://developer.android.com/topic/libraries/data-binding

dataBinding = true INSTEAD OF viewBinding
To use data binding in any Kotlin project, you should apply the kotlin-kapt plugin.

binding = DataBindingUtil.inflate(inflater, R.layout.game_fragment, container, false)
<layout xmlns:android="http://schemas.android.com/apk/res/android"
   xmlns:app="http://schemas.android.com/apk/res-auto"
   xmlns:tools="http://schemas.android.com/tools">

   <data>
    <!-- binding.gameViewModel = viewModel -->
<variable
       name="gameViewModel"
       type="com.example.android.unscramble.ui.game.GameViewModel" />
       <variable
              name="maxNoOfWords"
              type="int" />
   </data>

   <!-- wrapped content

    android:text="@{gameViewModel.currentScrambledWord}"
    android:text="@{@string/example_resource(user.lastName)}"
    -->
</layout>

binding.lifecycleOwner = viewLifecycleOwner
binding.lifecycleOwner = this