Main thread display UI + events (This is (usually) the UI thread.)
Background thread

multitasking / Concurrency

Coroutines enable multitasking, but provide another level of abstraction over simply working with threads.
One key feature of coroutines is the ability to store state, so that they can be halted and resumed. A coroutine may or may not execute.

* job: cancellable work
* CoroutineScope: create coroutines
* Dispatcher: determine thread by used coroutine
    The Main dispatcher will always run coroutines on the main thread,
    while dispatchers like Default, IO, or Unconfined will use other threads.

GlobalScope.launch {}
= as long as the app is running

Suspend signals that a block of code or function can be paused or resumed.
suspend fun() {}
delay(3000)
if call suspend, then suspend

.runBlocking {}
.async {}
    .await()
    Deferred = Promise = Future, promise that a result will be returned later

https://developer.android.com/kotlin/coroutines

------------
------------
GET POST PUT DELETE
Content-type

Most web servers today run web services using a common stateless web architecture known as REST,
which stands for REpresentational State Transfer.
Web services that offer this architecture are known as RESTful services.

Retrofit Library
https://github.com/square/retrofit

// Retrofit
implementation "com.squareup.retrofit2:retrofit:2.9.0"
// Retrofit with Scalar Converter: converter enables Retrofit to return the JSON result as a String
implementation "com.squareup.retrofit2:converter-scalars:2.9.0"

Need support for Java8.

* network/XXXApiService.kt cool name
* private const val BASE_URL
* private val retrofit = Retrofit.Builder()
    * opt: .addConverterFactory(ScalarsConverterFactory.create())
    .baseUrl(BASE_URL)
    .build()
interface XXXApiService {
    @GET("route") // get request to retrosfit
    fun assMethod()
}

object MarsApi {
    val retrofitService : MarsApiService by lazy {
       retrofit.create(MarsApiService::class.java) }
}

MarsApi.retrofitService.YOU
catch (e: Exception)

A ViewModelScope is the built-in coroutine scope defined for each ViewModel in your app.
Any coroutine launched in this scope is automatically canceled if the ViewModel is cleared.
viewModelScope.launch {}

-------------------
Permissions
https://developer.android.com/guide/topics/permissions/overview
<uses-permission android:name="android.permission.INTERNET" />
-------------------

moshi
https://github.com/square/moshi
// Moshi
implementation 'com.squareup.moshi:moshi-kotlin:1.13.0'

// Retrofit with Moshi Converter - replace previous imports
implementation 'com.squareup.retrofit2:converter-moshi:2.9.0'

data class XXX(
    @Json(name = "img_src_if_needed")
    with the fields of the JSON
)

private val moshi = Moshi.Builder()
   .add(KotlinJsonAdapterFactory())
   .build()

.addConverterFactory(MoshiConverterFactory.create(moshi))

------------

class MainActivity : AppCompatActivity(R.layout.activity_main)
==
class MainActivity : AppCompatActivity() {

   override fun onCreate(savedInstanceState: Bundle?) {
       super.onCreate(savedInstanceState)
       setContentView(R.layout.activity_main)
   }
}