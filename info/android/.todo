* Pick android version
* Switch Project View / IntelliJ-features
* Device emulator
=> Layout Inspector
=> Advanced controls (charging...)

------- Material -------

Material design is a library of pre-made components. Google recommends to use Material UI components as much as possible. The list [of Material components for Android can be found here](https://material.io/components?platform=android).

* Text field: `TextInputLayout` (see [text field](https://material.io/components/text-fields/android#using-text-fields))
* Switch: `SwitchMaterial` (create a switch, change the type in the .xml)

TextInputLayout comes with a built-in functionality to display error messages.
xxx.error = getString(R.string.error)
xxx.error = null // clear
xxx.isErrorEnabled = true

style="?attr/materialButtonOutlinedStyle"

https://m3.material.io/design/material-studies/shrine.html

------- Icons --------

different manufacturers may show app icons in a different shape than
the circular icon shape :  square shape, rounded square, or squircle (between a square and circle)...

https://developer.android.com/training/multiscreen/screendensities#TaskProvideAltBmp

Adaptive icons since v26
=> background
=> foreground
=> + new image asset
    => new assets should be moved in the same folder v26

https://developer.android.com/codelabs/basic-android-kotlin-training-display-list-cards
3 => easy way to import icon

https://developer.android.com/reference/com/google/android/material/card/MaterialCardView

------------------

A task is a collection of activities
Activities are arranged in a stack, known as a back stack
where each new activity the user visits gets pushed onto the back stack for the task
back = remove act on top and destroy it "popping an activity off the stack"
if no more, back to home

There is also a fragment stack in an activity
Navigation library

On an action, there is an attribute "popUpTo". It means that
destination in the stack will be popped off until the last one is the given one.
You may want to even remove the given one, by setting "popUpToInclusive" to true.
For instance, if you start wit A, go to D, and go back to A with popUpTo, you will have AA.

val intent = Intent(Intent.ACTION_SEND)
    .setType("text/plain")
    .putExtra(Intent.EXTRA_SUBJECT, "xxx")
    .putExtra(Intent.EXTRA_TEXT, "yyy")
    .putExtra(Intent.EXTRA_EMAIL, "a@b.c")

if (activity?.packageManager?.resolveActivity(intent, 0) != null) {
    startActivity(intent)
}

quantity strings
<plurals name="xxx">
    <item quantity="one">xxx</item>
    <item quantity="other">xxs</item>
</plurals>
Use resources.getQuantityString with quantity="one"/"other"
%1

--------------
Call executePendingBindings() after setting the property, which causes the update to execute immediately.
This is important, because it forces the data binding to execute immediately,
which allows the RecyclerView to make the correct view size measurements.
Situation: using images.

@BindingAdapter("listData")
fun bindRecyclerView(recyclerView: RecyclerView, data: List<MarsPhoto>?) {
    val adapter = recyclerView.adapter as PhotoGridAdapter
    adapter.submitList(data)
}

imageView.visibility = View.VISIBLE / GONE

@Query("id")
@GET("xxx/{id}")
suspend fun xxx(@Path("id") id: Int): yyy
https://square.github.io/retrofit/

----------
Long or battery intensive tasks.
With the previous APIs, you don't have guarantees that you job will be executed.
Android Jetpack WorkManager, backward-compatible, you are guaranteed that you job will be executed,
even if the app is closed, or the device restarts.

Worker(context, params) : extend this class, put your code in "doWork()". Return a Result.
    => applicationContext to get back the context
    => Result.success()
    => Result.failure()

Constraints.Builder()
.setRequireCharging(...)
...
.build() to create constraints

WorkerRequest: take a worker, and constraints. OneTimeWorkRequestBuilder<Worker>().setConstraints().build()
=> frequency
=> provide data: setInputData(Data.Builder().putString(key, value).build())
    => in the code, use inputData.getString(key)
    => output data: Result.success(workDataOf(key to value))

WorkManager: enqueue requests, WorkManager.enqueue(WorkerRequest)
WorkManager.enqueue(OneTimeWorkRequest.from(Worker::class.java)
WorkManager.getInstance(context)
=> in the viewModel: private val workManager = WorkManager.getInstance(application)

You can chain requests
.beginWith(listOf())
.then()
.then()
.build()

https://github.com/googlecodelabs/android-workmanager/blob/start_kotlin/app/src/main/java/com/example/background/workers/WorkerUtils.kt

// WorkManager dependency
implementation "androidx.work:work-runtime-ktx:2.7.1"

unique work chains
=> beginUniqueWork
=> avoid having two time the same chain running
    => key
    => a ExistingWorkPolicy: REPLACE, KEEP or APPEND.

=> LiveData<List<WorkInfo>> to
    => keep track of the state (BLOCKED, CANCELLED, ENQUEUED, FAILED, RUNNING or SUCCEEDED) of a WorkRequest
    => if the request is finished, the output data, if any
=> you can get your work request info, by using an Id, a tag, or a unique chain name
    => workManager.getWorkInfoByIdLiveData()
    => workManager.getWorkInfosForUniqueWorkLiveData()
    => workManager.getWorkInfosByTagLiveData()
        => you will have to call .addTag(TAG_OUTPUT) on your WorkRequest

override fun onCreate(savedInstanceState: Bundle?) {
    ...
    // Observe work status, added in onCreate()
    viewModel.outputWorkInfos.observe(this, workInfosObserver())
}

// Define the observer function
private fun workInfosObserver(): Observer<List<WorkInfo>> {
    return Observer { listOfWorkInfo ->

        // Note that these next few lines grab a single WorkInfo if it exists
        // This code could be in a Transformation in the ViewModel; they are included here
        // so that the entire process of displaying a WorkInfo is in one location.

        // If there are no matching work info, do nothing
        if (listOfWorkInfo.isNullOrEmpty()) {
            return@Observer
        }

        // We only care about the one output status.
        // Every continuation has only one worker tagged TAG_OUTPUT
        val workInfo = listOfWorkInfo[0]

        if (workInfo.state.isFinished) {
            showWorkFinished()

            // Normally this processing, which is not directly related to drawing views on
            // screen would be in the ViewModel. For simplicity we are keeping it here.
            val outputImageUri = workInfo.outputData.getString(KEY_IMAGE_URI)
        } else {
            showWorkInProgress()
        }
    }
}

=> workManager.cancelUniqueWork(key)

-------------
To fix this, you need to tell the RecyclerView not to clip the inner contents to the padding using android:clipToPadding attribute.
 This makes it draw the scrolling view in the padding area. Go back to layout/fragment_overview.xml. Add android:clipToPadding attribute
 for the RecyclerView, set it to false.
--------
_status.value = MarsApiStatus.LOADING