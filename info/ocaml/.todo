https://www2.ocaml.org/learn/tutorials/structure_of_ocaml_programs.html
https://ocaml.org/manual/index.html#sec6
https://ocamlverse.github.io/
https://dev.realworldocaml.org/index.html
https://ocaml-learn-code.com/

https://ocaml.org/learn/tutorials/functional_programming.html

https://thealmarty.com/2018/09/25/lambda-calculus-in-ocaml-fun-and-function/
https://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf

https://github.com/esy/esy/issues/1232
https://en.wikipedia.org/wiki/ML_(programming_language)#Examples
https://ocaml.org/manual/index.html
https://ocaml.org/releases/4.12/ocaml-4.12-refman.pdf
https://ocaml.org/learn/tutorials/functional_programming.html
https://www.ocaml.org/learn/tutorials/a_first_hour_with_ocaml.html

* everything is a value: you can give a function to a function (higher-order function etc.), you can return a function.
* typing implicit: you don't have to write the types
* immutables: you can change the value inside a variable, unless you are destroying the old one and creating one with the same name
* purity: no side-effects, a function must returns something, no print, we should be able to predict the behavior of the program

https://github.com/giraud/reasonml-idea-plugin
https://giraud.github.io/reasonml-idea-plugin/

ocamlfind ocamlc -o test -package extlib,oUnit -linkpkg -g avl.ml test.ml

---------------------------

opam switch create 4.07.0
https://giraud.github.io/reasonml-idea-plugin/docs/contributing/plugin-architecture

.bashrc instead of /etc/profile
/etc/bash.bashrc : all

Set-Item -LiteralPath Env:PATH -Value "usr/bin"
Get-ChildItem Env:

cd "C:\Users\quent\Desktop\opam\bin"
Set-Item -LiteralPath Env:PATH -Value "C:\Users\quent\Desktop\opam\bin"
.\opam init --root "..\portable" --bypass-checks -a --no-setup --bare
.\opam switch create 4.12.0 --root "..\portable"

.\opam install ocamlformat  --root "..\portable" --yes
.\opam update  --root "..\portable"
.\opam upgrade --root "..\portable"
rename .exe

---------------------------

# Functional programming

You will write your code almost like you would
write some maths formulas. You will focus on "what to solve"
rather than "how to solve".

Some functional languages are
`Lisp`, `meta-languages` (SML, CAML, OCAML) or `Haskell`.

<hr class="sr">

The main concepts are

* Referential transparency
* First-class citizens
* Purity (pure functions)
* Implicit types
* Immutable

And with some explications

* **Referential transparency** means that since ``f(x)=y``,
  writing ``y`` or `f(x)` is the same. `f(x)-f(x)` is
  equals to 0.
* **First-class citizens** (citoyen de premier
  ordre in French): functions are called first-class
  citizens, they can be used as parameters of others functions
  (a function taking another function is called a
  Higher-Order function or Fonction d'ordre sup√©rieur
  in French)
* Following the concept above, in functional languages, everything
  is a value, a function, an assignation too! We are writing expressions
  (evaluated as a value) and not a statement (assigning a variable, ...)
* **Implicit types** means you usually don't explicitly write
  the type of a variable
*  **Immutable** means that you can't change the value of
   a variable unless you create a new one.
* **Purity** means that each statement of your code is an expression,
  meaning that a function must return something. Your code mustn't
  have side-effects (such as writing in a file) like a statement
  in your code that you can't predict the outcome.

You may read some articles

* [Wikipedia](https://en.wikipedia.org/wiki/Functional_programming#Concepts)
* [GeeksForGeeks](https://www.geeksforgeeks.org/functional-programming-paradigm/)
* French: https://leblogducodeur.fr/introduction-a-la-programmation-fonctionnelle/ (reported down - 12/08/2021)
* French: <https://ocaml.org/learn/tutorials/functional_programming.fr.html#Qu-39-est-ce-que-la-programmation-fonctionnelle>