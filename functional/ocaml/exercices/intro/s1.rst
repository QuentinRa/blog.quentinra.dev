================================
1. Maths en OCaml
================================

.. image:: https://img.shields.io/badge/correction-vérifiée-green.svg?style=flat&amp;colorA=E1523D&amp;colorB=007D8A
   :alt: correction vérifiée

Les fonctions ont étés
volontairement faites avec beaucoup de syntaxe, des
appels à des print_type plutôt que printf ont
étés fait dès que possible. Et enfin dans la mesure
du possible, le code a été écrit en fonctionnel pur.

Notez un choix personnel d'utiliser "(argument, ...)"
pour les arguments des fonctions plutôt
que de mettre "argument argument" (ce n'est pas juste une syntaxe
différente mais bien un type différent).

.. code:: ocaml

		(* on sait que arctan(1)*4=~pi

		On note que ce sont des flottants
		donc on vera utiliser *.
		et print_float

		La fonction atan corresponds à arctan
		sa signature est float -> float

		*)
		let pi = (let x = 1.0 in atan(x) *. 4.0);;
		let _ = Printf.printf "--- Calcul de pi\n";;
		print_float (pi);;
		print_endline ("");;

		(*

		On sait que le volume d'une sphère
		corresponds à (4 * pi * r^3)/3

		On fait donc une fonction qui prends un r
		et qui retourne le calcul.

		la fonction est de type
		float -> float.

		*)
		let volume = fun r -> ((4.0 *. pi *. r *. r *. r)/.(3.0));;
		let _ = Printf.printf "--- Calcul de volume\n";;
		print_float (volume 3.0);; (* on a un peu près la bonne valeur, a cause de pi *)
		print_endline ("");;
		print_float (volume 5.0);; (* on a un peu près la bonne valeur, a cause de pi *)
		print_endline ("");;

		(*

		On sait qu'un nombre est pair si nombre%2 vaut 0, sinon
		il est impair.

		On fait une fonction de type int -> bool donc qui prends
		un entier et retourne pair=true et impair=false.

		*)
		let parite = fun n -> (if n mod 2 = 0 then true else false)
		let _ = Printf.printf "--- Calcul de parité\n";;
		let _ = Printf.printf "%d est pair ? %b\n" 4 (parite 4);;
		let _ = Printf.printf "%d est pair ? %b\n" 5 (parite 5);;
		let _ = Printf.printf "%d est pair ? %b\n" 1242 (parite 1242);;

		(*

		Même principe que précédemment mais la fonction
		est de type int->string donc prends un entier
		et retourne "pair" ou "impair".

		*)

		let parite_s = fun n -> (if n mod 2 = 0 then "pair" else "impair")
		let _ = Printf.printf "--- Calcul de parité (2)\n";;
		let _ = Printf.printf "%d est pair ? %s\n" 4 (parite_s 4);;
		let _ = Printf.printf "%d est pair ? %s\n" 5 (parite_s 5);;
		let _ = Printf.printf "%d est pair ? %s\n" 1242 (parite_s 1242);;

		(*

		Même qui précédemment mais cette on retourne (int->string)

				- L'entier n est pair
				- L'entier n est impair

		Pour suivre une logique fonctionnelle, j'ai fait en sorte
		que la fonction n'ai pas trop d'effets de bord (donc pas de print dedans)
		même si ...

		*)

		let parite_p = fun n -> ("L'entier "^string_of_int(n)^" est "^parite_s(n))
		let _ = Printf.printf "--- Calcul de parité (3)\n";;
		let _ = Printf.printf "%s\n" (parite_p 4);;
		let _ = Printf.printf "%s\n" (parite_p 5);;
		let _ = Printf.printf "%s\n" (parite_p 1242);;

		(*
		Soit h l'hypoténuse et c1,c2 les deux autres côtés d'un triangle.
		On sait que h^2=c1^2+c2^2 est vrai dans un triangle rectangle.

		La fonction is_rectangle va retourner vrai si donné h,c1,c2
		alors le triangle est rectangle.

		Son type est (c1,c2,h) -> bool soit float * float * float -> bool

		*)
		let is_rectangle = fun (c1,c2,h) -> (if (c1*.c1+.c2*.c2)=(h*.h) then true else false);;
		let _ = Printf.printf "--- Triangle rectangle\n";;
		let _ = Printf.printf "rectangle (c1=%f,c1=%f,h=%f) ? %b \n" 1.0 4.0 5.0 (is_rectangle (1.0,4.0,5.0));;
		let _ = Printf.printf "rectangle (c1=%f,c1=%f,h=%f) ? %b \n" 5.0 12.0 13.0 (is_rectangle (5.0,12.0,13.0));;

		(*

		Fonction qui calcule la dérivée en un point (approximativement)
		- un pas dx
		- une fonction
		- point
		donc (f(x+dx) - f(x))/dx

		donc (float, fun, float) -> fun

		*)

		let derive = fun (dx,f,x) -> ((f(x+.dx) -. f(x))/.(dx));;
		let _ = Printf.printf "--- Dérivée\n";;
		(* cos' en zéro = -sin(x) puis -sin(1.0) = -0.84 donc ok *)
		let _ = Printf.printf "résultat %f\n" (derive (0.00000001,cos,1.0));;

		(*

		f rond g = g(f(x))

		Donc on fait une fonction
		fun1 * fun2 * int -> fun3
		avec f3 la composée de f1 par f2
		en x.

		*)
		let carre = fun x -> x*x;;
		let plus_un = fun x -> x+1;;
		let composee = fun (f1,f2) -> (fun x -> f2 (f1 x));;
		let f_rond_g = composee (carre,plus_un);;
		let _ = Printf.printf "--- Composée\n";;
		let _ = Printf.printf "résultat de f ⚬ g = %d" (f_rond_g 3);;

**Crédits**
	* Quentin RAMSAMY--AGEORGES (étudiant à l'ENSIIE)